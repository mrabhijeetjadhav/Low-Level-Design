#  Core Components of Low-Level Design (LLD)
### Mastering Code-Level Design for Top Tech Companies

---

## Table of Contents

1. [Core Elements of Low-Level Design](#1-core-elements-of-low-level-design)
   - [Classes and Objects](#1-classes-and-objects)
   - [Interfaces and Abstractions](#2-interfaces-and-abstractions)
   - [Relationships Between Classes](#3-relationships-between-classes)
   - [Method Signatures](#4-method-signatures)
2. [Classes & Responsibilities (Single Responsibility Principle)](#2-classes--responsibilities-single-responsibility-principle)
   - [Bad Design (Violates SRP)](#bad-design-violates-srp)
   - [Good Design (Follows SRP)](#good-design-follows-srp)
3. [Relationships: Composition vs Inheritance](#3-relationships-composition-vs-inheritance)
   - [Composition (Preferred - "Has-A" Relationship)](#composition-preferred---has-a-relationship)
   - [Inheritance (Use Sparingly - "Is-A" Relationship)](#inheritance-use-sparingly---is-a-relationship)
4. [Interfaces & Abstractions](#4-interfaces--abstractions)
   - [Example: Payment Abstraction](#example-payment-abstraction)
   - [Client Code](#client-code-doesnt-care-about-implementation)
   - [Benefits of Interfaces](#benefits-of-interfaces)
5. [SOLID Principles in Practice](#5-solid-principles-in-practice)
   - [S - Single Responsibility Principle (SRP)](#s---single-responsibility-principle-srp)
   - [O - Open/Closed Principle (OCP)](#o---openclosed-principle-ocp)
   - [L - Liskov Substitution Principle (LSP)](#l---liskov-substitution-principle-lsp)
   - [I - Interface Segregation Principle (ISP)](#i---interface-segregation-principle-isp)
   - [D - Dependency Inversion Principle (DIP)](#d---dependency-inversion-principle-dip)
6. [Design Patterns (Very Important)](#6-design-patterns-very-important)
   - [Strategy Pattern Example](#strategy-pattern-example)
   - [Factory Pattern Example](#factory-pattern-example)
   - [Singleton Pattern Example](#singleton-pattern-example)
   - [Repository Pattern Example](#repository-pattern-example)
7. [Data Structures & Performance Considerations](#7-data-structures--performance-considerations)
   - [Time Complexity Comparison](#time-complexity-comparison)
   - [Example: Cache Implementation](#example-cache-implementation)
   - [Async/Await for Performance](#asyncawait-for-performance)
8. [Error Handling & Validation](#8-error-handling--validation)
   - [Input Validation](#input-validation)
   - [Exception Handling](#exception-handling)
   - [Defensive Programming](#defensive-programming)
9. [Dependency Injection & Testability](#9-dependency-injection--testability)
   - [Without DI (Hard to Test)](#without-di-hard-to-test)
   - [With DI (Easy to Test)](#with-di-easy-to-test)
   - [DI Container Setup (ASP.NET Core)](#di-container-setup-aspnet-core)
10. [Importance of LLD](#10-importance-of-lld)
11. [Real-World Interview Questions](#11-real-world-interview-questions)
    - [Google Questions](#google-questions)
    - [Microsoft Questions](#microsoft-questions)
    - [Amazon Questions](#amazon-questions)
    - [Meta/Netflix Questions](#metanetflix-questions)
12. [LLD Checklist & Best Practices](#12-lld-checklist--best-practices)
    - [Before You Start Coding](#before-you-start-coding)
    - [During Design](#during-design)
    - [Code Quality Checks](#code-quality-checks)
    - [Interview Tips](#interview-tips)
13. [Summary](#summary)

---

## 1. Core Elements of Low-Level Design

Where LLD Fits in the Development Process

```
Requirements
     ↓
High-Level Design (HLD)
     ↓
Low-Level Design (LLD) ← You are here
     ↓
Code Implementation
     ↓
Testing & Deployment
```

**LLD bridges the gap between architecture and code.**  
It defines the internal structure of components using classes, interfaces, and design patterns.

**Key Question LLD Answers:**  
*"How will this component be implemented to ensure it's maintainable, testable, and extensible?"*   
By keeping classes small, depending on abstractions, using DI and patterns like Strategy or Factory, I ensure the component is easy to maintain, easy to test, and easy to extend without breaking existing behavior.

---

Low-Level Design focuses on translating high-level architecture into concrete, implementable components. Let’s break down the key elements LLD emphasizes.

## 1. Classes and Objects

This is where detailed design truly begins. You identify the core entities in the system and define their responsibilities.

**Key questions to ask:**

- What are the main classes in the system?
- What responsibility does each class own?
- What data does each class maintain (attributes)?
- What behaviors does each class expose (methods)?

**Example – Food Delivery System**   
Possible classes include:
- Customer – places orders
- Restaurant – prepares food
- DeliveryAgent – delivers orders
- Order – represents the transaction

**Order class design:**
- **Attributes:** orderId, customerId, items, totalAmount, status
- **Methods:**
    - calculateTotal()
    - addItem(Item item)
    - updateStatus(OrderStatus newStatus)

Each class follows the Single Responsibility Principle, ensuring clarity, testability, and maintainability.

## 2. Interfaces and Abstractions

Interfaces define contracts between components. They enable loose coupling by separating what a class does from how it does it.

**Ask yourself:**
- What functionality should be exposed to other components?
- What implementation details should remain hidden?
- Which parts of the system are likely to change or have multiple variations?

**Example – Payment Processing** 
Define a common interface:
- PaymentProcessor

Multiple implementations:
- StripePaymentProcessor
- RazorpayPaymentProcessor
- PayPalPaymentProcessor

The core business logic depends only on the PaymentProcessor interface. This makes the system:

- Easy to extend (add a new payment provider)
- Easy to modify (switch providers)
- Easy to test (mock implementations)

## 3. Relationships Between Classes

Classes rarely exist in isolation. LLD clearly defines how classes are connected and how they interact.

**Common relationship types:**

- **Association (uses-a):**
    A loose relationship.
    Example: A Doctor uses a Stethoscope.

- **Aggregation (weak has-a):**
Objects can exist independently.
Example: A Department has Professors. Closing the department does not destroy professors.

- **Composition (strong has-a):**
Lifecycles are tightly coupled.
Example: A House is composed of Rooms. Destroying the house destroys the rooms.

- **Inheritance (is-a):**
A subclass inherits behavior and properties from a parent class.
Example: A Car is a Vehicle.


**Cardinality (Multiplicity):**

- One-to-One: A User has one Profile
- One-to-Many: A Customer can have multiple Orders
- Many-to-Many: A Student enrolls in multiple Courses, and each Course has many Students

## 4. Method Signatures

Once classes and relationships are defined, you specify how classes behave through methods. A well-designed method signature is clear, expressive, and self-documenting.

Decide:
- What methods should be public vs. private?
- What parameters and return types are needed?
- Should the method be synchronous or asynchronous?
- What exceptions should be handled or propagated?

Example:

❌ Poor design:

```c#
void sendMsg(String str)
```

✅ Better design:
```c#
void sendNotification(Message message)
```

Clear and meaningful method signatures:
- Improve readability
- Reduce misuse
- Make the system easier to extend (e.g., adding new notification types)

## 2. Classes & Responsibilities (Single Responsibility Principle)

**Principle:** Each class should have one, and only one, reason to change.

### Bad Design (Violates SRP)
```csharp
class OrderManager
{
    public void SaveOrder(Order order)
    {
        // Database logic
        var connection = new SqlConnection();
        // Save to DB
    }
    
    public void SendConfirmationEmail(Order order)
    {
        // Email logic
        var emailClient = new SmtpClient();
        // Send email
    }
    
    public void ProcessPayment(Order order)
    {
        // Payment logic
        var paymentGateway = new StripeClient();
        // Process payment
    }
}
```
**Problems:**
- Three reasons to change (DB, Email, Payment)
- Hard to test
- Tight coupling
- Code duplication across projects

### Good Design (Follows SRP)
```csharp
class OrderService
{
    private readonly IOrderRepository _repository;
    private readonly IEmailService _emailService;
    private readonly IPaymentService _paymentService;
    
    public OrderService(
        IOrderRepository repository,
        IEmailService emailService,
        IPaymentService paymentService)
    {
        _repository = repository;
        _emailService = emailService;
        _paymentService = paymentService;
    }
    
    public void PlaceOrder(Order order)
    {
        _paymentService.Process(order.Payment);
        _repository.Save(order);
        _emailService.SendConfirmation(order);
    }
}

class OrderRepository : IOrderRepository
{
    public void Save(Order order) { /* DB logic only */ }
}

class EmailService : IEmailService
{
    public void SendConfirmation(Order order) { /* Email logic only */ }
}

class PaymentService : IPaymentService
{
    public void Process(Payment payment) { /* Payment logic only */ }
}
```

**Benefits:**
- Each class has one responsibility
- Easy to test in isolation
- Changes to email don't affect payment
- Reusable across services

---

### Google Follow-up:
**Q: What if one class does everything?**  
→ The class becomes a "God Object"—difficult to debug, test, extend, and maintain. Changes ripple across unrelated functionality.

**Q: How do you identify if a class has too many responsibilities?**  
→ If the class name has "and" in it (OrderAndPayment), or if changes for different reasons affect the same class, it violates SRP.

**Q: What are the benefits of SRP?**  
→ Easier testing, better maintainability, reduced coupling, clearer code organization, and parallel development by teams.

---

## 3. Relationships: Composition vs Inheritance vs Association vs Aggregation

Understanding class relationships is crucial for designing maintainable systems. Each relationship type serves a specific purpose and has different implications for coupling, lifecycle management, and code flexibility.

### Quick Comparison Table

| Relationship | Type | Lifecycle | Coupling | Notation | Example |
|--------------|------|-----------|----------|----------|---------|
| **Association** | Uses-A | Independent | Loose | Regular line | Driver uses Car |
| **Aggregation** | Weak Has-A | Independent | Medium | Hollow diamond | Department has Professors |
| **Composition** | Strong Has-A | Dependent | Strong | Filled diamond | House has Rooms |
| **Inheritance** | Is-A | Hierarchical | Very Strong | Hollow arrow | Dog is an Animal |

---

### 1. Association (Uses-A Relationship)

**Definition:** A loose relationship where one class uses or interacts with another, but neither owns the other. Both objects have independent lifecycles.

**Characteristics:**
- Weakest form of relationship
- Objects exist independently
- Temporary or permanent relationship
- No ownership implied

**When to use:**
- Objects collaborate but don't own each other
- Relationship can be established/broken at runtime
- Multiple objects can share the same reference

```csharp
// Example: Doctor uses Stethoscope (but doesn't own it)
public class Stethoscope
{
    public string Brand { get; set; }
    public void Listen()
    {
        Console.WriteLine("Listening to heartbeat...");
    }
}

public class Doctor
{
    public string Name { get; set; }
    
    // Association: Doctor uses Stethoscope but doesn't own it
    public void ExaminePatient(Stethoscope stethoscope)
    {
        Console.WriteLine($"Dr. {Name} examining patient");
        stethoscope.Listen();
        // Stethoscope continues to exist after examination
    }
}

// Usage
var stethoscope = new Stethoscope { Brand = "Littmann" };
var doctor1 = new Doctor { Name = "John" };
var doctor2 = new Doctor { Name = "Sarah" };

doctor1.ExaminePatient(stethoscope);  // Dr. John uses stethoscope
doctor2.ExaminePatient(stethoscope);  // Dr. Sarah uses same stethoscope
// Stethoscope exists independently
```

**Real-world examples:**
- `Driver` uses `Car` (driver doesn't own the car)
- `Teacher` teaches `Student` (temporary interaction)
- `Customer` places `Order` (bidirectional association)

**How to identify:** Ask "Does object A use object B temporarily without owning it?"

---

### 2. Aggregation (Weak Has-A Relationship)

**Definition:** A "whole-part" relationship where the part can exist independently of the whole. The container doesn't control the lifecycle of contained objects.

**Characteristics:**
- Parts can exist without the whole
- Parts can belong to multiple wholes
- Weaker ownership
- Child objects have independent lifecycle

**When to use:**
- Container collects objects but doesn't create/destroy them
- Objects can be shared across multiple containers
- Objects should survive even if container is destroyed

```csharp
// Example: Department has Professors (but professors can exist without department)
public class Professor
{
    public string Name { get; set; }
    public string Specialization { get; set; }
    
    public void Teach()
    {
        Console.WriteLine($"Professor {Name} teaching {Specialization}");
    }
}

public class Department
{
    public string Name { get; set; }
    private List<Professor> _professors;
    
    public Department(string name)
    {
        Name = name;
        _professors = new List<Professor>();
    }
    
    // Aggregation: Department has professors but doesn't own them
    public void AddProfessor(Professor professor)
    {
        _professors.Add(professor);
    }
    
    public void RemoveProfessor(Professor professor)
    {
        _professors.Remove(professor);
    }
    
    public void ListProfessors()
    {
        Console.WriteLine($"Department: {Name}");
        foreach (var prof in _professors)
        {
            Console.WriteLine($"  - {prof.Name}");
        }
    }
}

// Usage
var prof1 = new Professor { Name = "Dr. Smith", Specialization = "Mathematics" };
var prof2 = new Professor { Name = "Dr. Jones", Specialization = "Physics" };

var mathDept = new Department("Mathematics");
mathDept.AddProfessor(prof1);
mathDept.AddProfessor(prof2);

var scienceDept = new Department("Science");
scienceDept.AddProfessor(prof2);  // Same professor in multiple departments

mathDept = null;  // Department destroyed
// prof1 and prof2 still exist independently
```

**Real-world examples:**
- `Library` has `Books` (books can be transferred to another library)
- `Team` has `Players` (players can switch teams)
- `Playlist` has `Songs` (songs exist independently)
- `Course` has `Students` (students can drop the course)

**How to identify:** Ask "If I destroy the container, should the contained objects still exist?"

---

### 3. Composition (Strong Has-A Relationship - Preferred)

**Definition:** A strong "whole-part" relationship where the part cannot exist without the whole. The container controls the lifecycle of contained objects.

**Characteristics:**
- Parts cannot exist independently
- Strong ownership
- When whole is destroyed, parts are destroyed
- Tightly coupled lifecycles

**When to use:**
- Part is meaningless without the whole
- Container creates and manages the parts
- Parts should be destroyed with the container
- Need strong encapsulation

```csharp
// Example: House has Rooms (rooms cannot exist without house)
public class Room
{
    public string Name { get; set; }
    public double Area { get; set; }
    
    internal Room(string name, double area)  // Internal constructor
    {
        Name = name;
        Area = area;
        Console.WriteLine($"Room '{name}' created");
    }
}

public class House
{
    public string Address { get; set; }
    private List<Room> _rooms;
    
    public House(string address)
    {
        Address = address;
        _rooms = new List<Room>();
        Console.WriteLine($"House at {address} constructed");
        
        // Composition: House creates and owns rooms
        _rooms.Add(new Room("Living Room", 400));
        _rooms.Add(new Room("Bedroom", 300));
        _rooms.Add(new Room("Kitchen", 200));
    }
    
    public void ShowRooms()
    {
        Console.WriteLine($"\nHouse at {Address} contains:");
        foreach (var room in _rooms)
        {
            Console.WriteLine($"  - {room.Name}: {room.Area} sq ft");
        }
    }
    
    ~House()
    {
        Console.WriteLine($"House at {Address} demolished - all rooms destroyed");
        // When house is destroyed, rooms are automatically destroyed
    }
}

// Another example: Car and Engine
public class Engine
{
    public string Type { get; set; }
    public int Horsepower { get; set; }
    
    internal Engine(string type, int hp)
    {
        Type = type;
        Horsepower = hp;
    }
    
    public void Start()
    {
        Console.WriteLine($"{Type} engine started ({Horsepower} HP)");
    }
}

public class Car
{
    public string Model { get; set; }
    private Engine _engine;  // Composition: Car owns engine
    
    public Car(string model, string engineType, int horsepower)
    {
        Model = model;
        _engine = new Engine(engineType, horsepower);  // Car creates engine
    }
    
    public void Drive()
    {
        _engine.Start();
        Console.WriteLine($"{Model} is driving");
    }
    
    // When car is destroyed, engine is destroyed too
}

// Usage
var house = new House("123 Main St");
house.ShowRooms();
// When house goes out of scope, rooms are destroyed automatically

var car = new Car("Tesla Model 3", "Electric", 450);
car.Drive();
// Engine cannot exist independently of the car
```

**Why prefer composition?**  
- ✅ More flexible—easy to change behavior at runtime
- ✅ Avoids deep inheritance trees
- ✅ Better encapsulation
- ✅ Easier to test and mock
- ✅ Reduces coupling
- ✅ Follows "favor composition over inheritance" principle

**Real-world examples:**
- `Order` has `OrderItems` (order items meaningless without order)
- `Book` has `Pages` (pages are part of the book)
- `Human` has `Heart` (heart is integral to human)
- `Document` has `Paragraphs` (paragraphs belong to document)

**How to identify:** Ask "Does the part make sense without the whole?" If no, use composition.

---

### 4. Inheritance (Is-A Relationship - Use Sparingly)

**Definition:** A hierarchical relationship where a subclass inherits properties and behavior from a parent class.

**Characteristics:**
- Strongest coupling
- Code reuse through inheritance
- Polymorphism support
- Fragile base class problem
- Rigid hierarchy

**When to use:**
- True "is-a" relationship exists
- Shared behavior belongs in base class
- Need polymorphism
- Hierarchy is stable and won't change frequently

```csharp
// Example: Employee hierarchy
public abstract class Employee
{
    public string Name { get; set; }
    public string EmployeeId { get; set; }
    public DateTime JoinDate { get; set; }
    
    public abstract decimal CalculateSalary();
    
    public void ClockIn()
    {
        Console.WriteLine($"{Name} (ID: {EmployeeId}) clocked in at {DateTime.Now}");
    }
    
    public void ClockOut()
    {
        Console.WriteLine($"{Name} clocked out");
    }
}

public class FullTimeEmployee : Employee  // FullTimeEmployee IS-AN Employee
{
    public decimal BaseSalary { get; set; }
    public decimal Benefits { get; set; }
    
    public override decimal CalculateSalary()
    {
        return BaseSalary + Benefits;
    }
}

public class ContractEmployee : Employee  // ContractEmployee IS-AN Employee
{
    public decimal HourlyRate { get; set; }
    public int HoursWorked { get; set; }
    
    public override decimal CalculateSalary()
    {
        return HourlyRate * HoursWorked;
    }
}

public class Intern : Employee  // Intern IS-AN Employee
{
    public decimal Stipend { get; set; }
    
    public override decimal CalculateSalary()
    {
        return Stipend;
    }
}

// Another example: Vehicle hierarchy
public abstract class Vehicle
{
    public string Brand { get; set; }
    public string Model { get; set; }
    public abstract void Start();
}

public class Car : Vehicle  // Car IS-A Vehicle
{
    public int NumberOfDoors { get; set; }
    
    public override void Start()
    {
        Console.WriteLine($"{Brand} {Model} car started");
    }
}

public class Motorcycle : Vehicle  // Motorcycle IS-A Vehicle
{
    public bool HasSidecar { get; set; }
    
    public override void Start()
    {
        Console.WriteLine($"{Brand} {Model} motorcycle started");
    }
}

// Usage demonstrating polymorphism
List<Employee> employees = new List<Employee>
{
    new FullTimeEmployee { Name = "John", BaseSalary = 5000, Benefits = 1000 },
    new ContractEmployee { Name = "Sarah", HourlyRate = 50, HoursWorked = 160 },
    new Intern { Name = "Mike", Stipend = 1500 }
};

foreach (var emp in employees)
{
    emp.ClockIn();
    Console.WriteLine($"Salary: ${emp.CalculateSalary()}");
}
```

**When to use inheritance?**  
→ When there's a genuine "is-a" relationship and shared behavior that belongs in the base class.

**Problems with inheritance:**
- ❌ Creates tight coupling
- ❌ Fragile base class problem
- ❌ Deep hierarchies become hard to understand
- ❌ Limited to single inheritance in most languages
- ❌ Changes to base class affect all derived classes

**Real-world examples:**
- `Dog` is an `Animal`
- `Circle` is a `Shape`
- `SavingsAccount` is a `BankAccount`
- `Manager` is an `Employee`

**How to identify:** Ask "Is object A a type of object B?" If yes and hierarchy is stable, use inheritance.

---

### Decision Guide: Which Relationship to Use?

```
START
  ↓
Does A use B temporarily without owning it?
  ↓ YES → Association
  ↓ NO
Does A contain B but B can exist independently?
  ↓ YES → Aggregation
  ↓ NO
Does A contain B and B cannot exist without A?
  ↓ YES → Composition (PREFERRED)
  ↓ NO
Is A a type of B? (True "is-a" relationship)
  ↓ YES → Inheritance (USE SPARINGLY)
  ↓ NO
  ↓
Reconsider your design
```

### Practical Rules of Thumb

1. **Default to Composition** - Most flexible, easiest to test
2. **Use Association** - For temporary or shared relationships
3. **Use Aggregation** - When objects can be shared across containers
4. **Use Inheritance** - Only for true "is-a" relationships with stable hierarchies

### Complete Example: Library Management System

```csharp
// Inheritance: Different types of library members
public abstract class LibraryMember
{
    public string MemberId { get; set; }
    public string Name { get; set; }
    public abstract int GetMaxBorrowLimit();
}

public class Student : LibraryMember
{
    public override int GetMaxBorrowLimit() => 3;
}

public class Faculty : LibraryMember
{
    public override int GetMaxBorrowLimit() => 10;
}

// Composition: Library card belongs to library system
public class LibraryCard
{
    public string CardNumber { get; set; }
    public DateTime ExpiryDate { get; set; }
}

public class Library
{
    private List<Book> _books;  // Aggregation: Books can move to other libraries
    
    public Library()
    {
        _books = new List<Book>();
    }
    
    public void AddBook(Book book)
    {
        _books.Add(book);
    }
    
    // Association: Member borrows book temporarily
    public void BorrowBook(LibraryMember member, Book book)
    {
        Console.WriteLine($"{member.Name} borrowed {book.Title}");
    }
}

public class Book
{
    public string ISBN { get; set; }
    public string Title { get; set; }
    public string Author { get; set; }
}
```

---

### Google/Microsoft Follow-up:
**Q: When would inheritance be okay?**  
→ When there's a true "is-a" relationship (ContractEmployee *is an* Employee), and you need polymorphism with shared base behavior.

**Q: What's wrong with deep inheritance hierarchies?**  
→ They become fragile, hard to understand, and changes to base classes can break derived classes unexpectedly. Prefer composition for flexibility.

**Q: Can you combine composition and inheritance?**  
→ Yes! Use inheritance for core abstractions and composition for behaviors (e.g., Employee *has a* SalaryCalculator, *has a* BenefitsManager).

**Q: How do you decide between Aggregation and Composition?**  
→ Ask: "If I destroy the container, should the contained object survive?" If yes → Aggregation. If no → Composition.

**Q: Why is "favor composition over inheritance" important?**  
→ Composition provides flexibility, reduces coupling, and avoids fragile base class problems. It's easier to change behavior at runtime and test in isolation.

---

## 4. Interfaces & Abstractions

Interfaces define contracts that classes must implement, enabling loose coupling and flexibility.

### Example: Payment Abstraction

```csharp
public interface IPaymentProcessor
{
    PaymentResult ProcessPayment(decimal amount, PaymentDetails details);
    bool ValidatePayment(PaymentDetails details);
    void RefundPayment(string transactionId);
}

public class StripePaymentProcessor : IPaymentProcessor
{
    public PaymentResult ProcessPayment(decimal amount, PaymentDetails details)
    {
        // Stripe-specific implementation
        return new PaymentResult { Success = true, TransactionId = "stripe_123" };
    }

    public bool ValidatePayment(PaymentDetails details)
    {
        return details.CardNumber.Length == 16;
    }

    public void RefundPayment(string transactionId)
    {
        // Stripe refund API call
    }
}

public class PayPalPaymentProcessor : IPaymentProcessor
{
    public PaymentResult ProcessPayment(decimal amount, PaymentDetails details)
    {
        // PayPal-specific implementation
        return new PaymentResult { Success = true, TransactionId = "paypal_456" };
    }

    public bool ValidatePayment(PaymentDetails details)
    {
        return !string.IsNullOrEmpty(details.Email);
    }

    public void RefundPayment(string transactionId)
    {
        // PayPal refund API call
    }
}
```

### Client Code (Doesn't care about implementation)

```csharp
class CheckoutService
{
    private readonly IPaymentProcessor _paymentProcessor;
    
    public CheckoutService(IPaymentProcessor paymentProcessor)
    {
        _paymentProcessor = paymentProcessor;
    }
    
    public void Checkout(Order order)
    {
        if (_paymentProcessor.ValidatePayment(order.PaymentDetails))
        {
            var result = _paymentProcessor.ProcessPayment(order.Total, order.PaymentDetails);
            // Process result
        }
    }
}
```

### Benefits of Interfaces

1. **Loose Coupling**: Code depends on abstractions, not concrete implementations
2. **Testability**: Easy to mock dependencies in unit tests
3. **Flexibility**: Swap implementations without changing client code
4. **Extensibility**: Add new implementations without modifying existing code (Open/Closed Principle)
5. **Clear Contracts**: Defines expected behavior explicitly

---

### Google Follow-up:
**Q: When should you avoid using interfaces?**  
→ When there's only one implementation and no foreseeable need for abstraction (e.g., simple utility classes). Over-abstraction adds unnecessary complexity.

**Q: Interface vs Abstract Class—when to use which?**  
→ Use interfaces for contracts and capabilities (can implement multiple). Use abstract classes when you need shared implementation and a common base.

---

## 5. SOLID Principles in Practice

### S - Single Responsibility Principle (SRP)
Each class should have one reason to change.

```csharp
// Bad: Multiple responsibilities
class UserService
{
    void SaveUser() {}  // DB responsibility
    void SendEmail() {}  // Email responsibility
    void GenerateReport() {}  // Reporting responsibility
}

// Good: Separated responsibilities
class UserRepository { void Save(User user) {} }
class EmailService { void Send(Email email) {} }
class ReportGenerator { Report Generate(User user) {} }
```

### O - Open/Closed Principle (OCP)
Open for extension, closed for modification.

```csharp
// Use Strategy pattern to extend behavior without modifying existing code
interface IDiscountStrategy
{
    decimal ApplyDiscount(decimal price);
}

class SeasonalDiscount : IDiscountStrategy
{
    public decimal ApplyDiscount(decimal price) => price * 0.9m;  // 10% off
}

class LoyaltyDiscount : IDiscountStrategy
{
    public decimal ApplyDiscount(decimal price) => price * 0.85m;  // 15% off
}

class PricingService
{
    public decimal CalculateFinalPrice(decimal basePrice, IDiscountStrategy strategy)
    {
        return strategy.ApplyDiscount(basePrice);
    }
}
```

### L - Liskov Substitution Principle (LSP)
Subtypes must be substitutable for their base types without breaking functionality.

```csharp
// Good: Proper abstraction
interface IShape
{
    double CalculateArea();
}

class Rectangle : IShape
{
    public double Width { get; set; }
    public double Height { get; set; }
    public double CalculateArea() => Width * Height;
}

class Square : IShape
{
    public double Side { get; set; }
    public double CalculateArea() => Side * Side;
}
```

### I - Interface Segregation Principle (ISP)
Clients shouldn't depend on interfaces they don't use.

```csharp
// Bad: Fat interface
interface IWorker
{
    void Work();
    void Eat();
    void Sleep();
}

// Good: Segregated interfaces
interface IWorkable { void Work(); }
interface IFeedable { void Eat(); }
interface IRestable { void Sleep(); }

class Human : IWorkable, IFeedable, IRestable
{
    public void Work() {}
    public void Eat() {}
    public void Sleep() {}
}

class Robot : IWorkable
{
    public void Work() {}
    // Robot doesn't need Eat() or Sleep()
}
```

### D - Dependency Inversion Principle (DIP)
Depend on abstractions, not concretions.

```csharp
// Bad: High-level class depends on low-level class
class OrderService
{
    private SqlDatabase db = new SqlDatabase();  // Tight coupling
}

// Good: Both depend on abstraction
interface IDatabase
{
    void Save(object data);
}

class OrderService
{
    private readonly IDatabase _database;
    
    public OrderService(IDatabase database)  // Dependency Injection
    {
        _database = database;
    }
}
```

---

### Microsoft Follow-up:
**Q: Which SOLID principle is most important?**  
→ All are important, but Dependency Inversion enables testability and flexibility. In large systems, DIP and SRP have the most impact.

**Q: How do SOLID principles help in interviews?**  
→ They demonstrate understanding of maintainable code design and are frequently asked at Microsoft, Google, and Amazon.

---

## 6. Design Patterns (Very Important)

Design patterns are proven solutions to common software design problems. Mastering them is crucial for LLD interviews.

| Pattern | Purpose | When to Use |
|---------|---------|-------------|
| **Strategy** | Define family of algorithms | Payment methods, sorting algorithms |
| **Factory** | Object creation | Creating objects based on conditions |
| **Singleton** | Single instance | Logging, configuration, connection pools |
| **Repository** | Data access abstraction | Database operations |
| **Observer** | Event notification | Pub-sub systems, event handling |
| **Decorator** | Add behavior dynamically | Adding features without inheritance |
| **Adapter** | Interface compatibility | Integrating third-party libraries |
| **Builder** | Complex object construction | Creating objects with many parameters |

---

### Strategy Pattern Example

**Problem:** Multiple payment methods with different implementations.

```csharp
// Define the strategy interface
interface IPaymentStrategy
{
    PaymentResult ProcessPayment(decimal amount);
    bool Validate();
}

// Concrete strategies
class CreditCardPayment : IPaymentStrategy
{
    private readonly string _cardNumber;
    
    public CreditCardPayment(string cardNumber)
    {
        _cardNumber = cardNumber;
    }
    
    public PaymentResult ProcessPayment(decimal amount)
    {
        Console.WriteLine($"Processing ${amount} via Credit Card");
        return new PaymentResult { Success = true };
    }
    
    public bool Validate()
    {
        return _cardNumber.Length == 16;
    }
}

class UpiPayment : IPaymentStrategy
{
    private readonly string _upiId;
    
    public UpiPayment(string upiId)
    {
        _upiId = upiId;
    }
    
    public PaymentResult ProcessPayment(decimal amount)
    {
        Console.WriteLine($"Processing ${amount} via UPI");
        return new PaymentResult { Success = true };
    }
    
    public bool Validate()
    {
        return _upiId.Contains("@");
    }
}

class PayPalPayment : IPaymentStrategy
{
    private readonly string _email;
    
    public PayPalPayment(string email)
    {
        _email = email;
    }
    
    public PaymentResult ProcessPayment(decimal amount)
    {
        Console.WriteLine($"Processing ${amount} via PayPal");
        return new PaymentResult { Success = true };
    }
    
    public bool Validate()
    {
        return _email.Contains("@");
    }
}

// Context class
class PaymentProcessor
{
    private readonly IPaymentStrategy _strategy;
    
    public PaymentProcessor(IPaymentStrategy strategy)
    {
        _strategy = strategy;
    }
    
    public PaymentResult Pay(decimal amount)
    {
        if (!_strategy.Validate())
        {
            return new PaymentResult { Success = false, Message = "Invalid payment details" };
        }
        
        return _strategy.ProcessPayment(amount);
    }
}

// Usage
var processor1 = new PaymentProcessor(new CreditCardPayment("1234567812345678"));
processor1.Pay(100);

var processor2 = new PaymentProcessor(new UpiPayment("user@bank"));
processor2.Pay(200);
```

**Why Strategy?**  
→ Add new payment methods without modifying existing code (Open/Closed Principle).

---

### Factory Pattern Example

**Problem:** Creating different types of objects based on input.

```csharp
// Product interface
interface INotification
{
    void Send(string message, string recipient);
}

// Concrete products
class EmailNotification : INotification
{
    public void Send(string message, string recipient)
    {
        Console.WriteLine($"Sending Email to {recipient}: {message}");
    }
}

class SmsNotification : INotification
{
    public void Send(string message, string recipient)
    {
        Console.WriteLine($"Sending SMS to {recipient}: {message}");
    }
}

class PushNotification : INotification
{
    public void Send(string message, string recipient)
    {
        Console.WriteLine($"Sending Push to {recipient}: {message}");
    }
}

// Factory class
class NotificationFactory
{
    public static INotification CreateNotification(string type)
    {
        return type.ToLower() switch
        {
            "email" => new EmailNotification(),
            "sms" => new SmsNotification(),
            "push" => new PushNotification(),
            _ => throw new ArgumentException($"Unknown notification type: {type}")
        };
    }
}

// Usage
var notification = NotificationFactory.CreateNotification("email");
notification.Send("Hello!", "user@example.com");
```

**Why Factory?**  
→ Centralize object creation logic and hide implementation details from clients.

---

### Singleton Pattern Example

**Problem:** Ensure only one instance of a class exists (e.g., Logger, Configuration).

```csharp
public sealed class Logger
{
    private static Logger _instance;
    private static readonly object _lock = new object();
    
    // Private constructor prevents external instantiation
    private Logger()
    {
        Console.WriteLine("Logger initialized");
    }
    
    public static Logger Instance
    {
        get
        {
            if (_instance == null)
            {
                lock (_lock)
                {
                    if (_instance == null)
                    {
                        _instance = new Logger();
                    }
                }
            }
            return _instance;
        }
    }
    
    public void Log(string message)
    {
        Console.WriteLine($"[{DateTime.Now}] {message}");
    }
}

// Usage
Logger.Instance.Log("Application started");
Logger.Instance.Log("User logged in");
```

**Why Singleton?**  
→ Control access to shared resources (logging, configuration, caching) and ensure thread-safe single instance.

---

### Repository Pattern Example

**Problem:** Abstract data access logic from business logic.

```csharp
// Entity
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
}

// Repository interface
public interface IProductRepository
{
    Product GetById(int id);
    IEnumerable<Product> GetAll();
    void Add(Product product);
    void Update(Product product);
    void Delete(int id);
}

// Concrete repository
public class ProductRepository : IProductRepository
{
    private readonly DbContext _context;
    
    public ProductRepository(DbContext context)
    {
        _context = context;
    }
    
    public Product GetById(int id)
    {
        return _context.Products.Find(id);
    }
    
    public IEnumerable<Product> GetAll()
    {
        return _context.Products.ToList();
    }
    
    public void Add(Product product)
    {
        _context.Products.Add(product);
        _context.SaveChanges();
    }
    
    public void Update(Product product)
    {
        _context.Products.Update(product);
        _context.SaveChanges();
    }
    
    public void Delete(int id)
    {
        var product = GetById(id);
        if (product != null)
        {
            _context.Products.Remove(product);
            _context.SaveChanges();
        }
    }
}

// Service layer uses repository
public class ProductService
{
    private readonly IProductRepository _repository;
    
    public ProductService(IProductRepository repository)
    {
        _repository = repository;
    }
    
    public Product GetProduct(int id)
    {
        return _repository.GetById(id);
    }
}
```

**Why Repository?**  
→ Separates data access from business logic, making code testable and database-agnostic.

---

### Amazon Follow-up:
**Q: What happens if you use if-else for payment types?**  
→ Code becomes unmanageable and violates Open/Closed Principle. Every new payment type requires modifying existing code.

```csharp
// Bad approach
void ProcessPayment(string type, decimal amount)
{
    if (type == "creditcard")
    {
        // Credit card logic
    }
    else if (type == "upi")
    {
        // UPI logic
    }
    else if (type == "paypal")
    {
        // PayPal logic
    }
    // Adding new type requires modifying this method
}
```

**Q: Which pattern would you use for creating database connections?**  
→ Singleton for connection pool management to reuse connections efficiently.

---

## 7. Data Structures & Performance Considerations

Choosing the right data structure directly impacts performance in LLD.

### Time Complexity Comparison

| Data Structure | Access | Search | Insert | Delete | Use Case |
|----------------|--------|--------|--------|--------|----------|
| **Array/List** | O(1) | O(n) | O(n) | O(n) | Sequential access |
| **Dictionary/HashMap** | O(1) | O(1) | O(1) | O(1) | Key-value lookups |
| **HashSet** | - | O(1) | O(1) | O(1) | Unique values, fast lookup |
| **LinkedList** | O(n) | O(n) | O(1) | O(1) | Frequent insertions/deletions |
| **Stack** | O(1) | - | O(1) | O(1) | LIFO operations |
| **Queue** | O(1) | - | O(1) | O(1) | FIFO operations |
| **SortedSet** | O(log n) | O(log n) | O(log n) | O(log n) | Sorted unique values |

### Example: Cache Implementation

```csharp
// Using Dictionary for O(1) lookups
public class ProductCache
{
    private readonly Dictionary<int, Product> _cache;
    private readonly IProductRepository _repository;
    
    public ProductCache(IProductRepository repository)
    {
        _cache = new Dictionary<int, Product>();
        _repository = repository;
    }
    
    public Product GetProduct(int id)
    {
        // O(1) cache lookup
        if (_cache.ContainsKey(id))
        {
            return _cache[id];
        }
        
        // Cache miss - fetch from DB
        var product = _repository.GetById(id);
        _cache[id] = product;
        return product;
    }
}
```

### Async/Await for Performance

```csharp
public class OrderService
{
    private readonly IPaymentService _paymentService;
    private readonly IInventoryService _inventoryService;
    private readonly IEmailService _emailService;
    
    public async Task<Order> PlaceOrderAsync(Order order)
    {
        // Run payment and inventory check in parallel
        var paymentTask = _paymentService.ProcessAsync(order.Payment);
        var inventoryTask = _inventoryService.ReserveAsync(order.Items);
        
        await Task.WhenAll(paymentTask, inventoryTask);
        
        // Send email notification (fire and forget)
        _ = _emailService.SendConfirmationAsync(order);
        
        return order;
    }
}
```

---

### Netflix Follow-up:
**Q: Where do you think about performance?**  
→ In LLD—choosing right data structures (Dictionary over List for lookups), using async operations, caching frequently accessed data, and avoiding N+1 queries.

**Q: What if performance is ignored early?**  
→ Costly refactors later, technical debt, and potential system failures under load.

---

## 8. Error Handling & Validation

Proper error handling is critical in production code.

### Input Validation

```csharp
public class OrderValidator
{
    public ValidationResult Validate(Order order)
    {
        var errors = new List<string>();
        
        if (order == null)
            errors.Add("Order cannot be null");
        
        if (order.Items == null || !order.Items.Any())
            errors.Add("Order must contain at least one item");
        
        if (order.TotalAmount <= 0)
            errors.Add("Total amount must be greater than zero");
        
        return new ValidationResult
        {
            IsValid = !errors.Any(),
            Errors = errors
        };
    }
}
```

### Exception Handling

```csharp
public class PaymentService
{
    private readonly IPaymentGateway _gateway;
    private readonly ILogger _logger;
    
    public async Task<PaymentResult> ProcessPaymentAsync(Payment payment)
    {
        try
        {
            var result = await _gateway.ChargeAsync(payment);
            return result;
        }
        catch (PaymentGatewayException ex)
        {
            _logger.LogError($"Payment failed: {ex.Message}");
            return new PaymentResult
            {
                Success = false,
                ErrorCode = ex.ErrorCode,
                Message = "Payment processing failed. Please try again."
            };
        }
        catch (Exception ex)
        {
            _logger.LogError($"Unexpected error: {ex}");
            throw; // Re-throw unexpected exceptions
        }
    }
}
```

### Defensive Programming

```csharp
public class UserService
{
    private readonly IUserRepository _repository;
    
    public User GetUser(int userId)
    {
        if (userId <= 0)
            throw new ArgumentException("User ID must be positive", nameof(userId));
        
        var user = _repository.GetById(userId);
        
        if (user == null)
            throw new NotFoundException($"User with ID {userId} not found");
        
        return user;
    }
}
```

---

## 9. Dependency Injection & Testability

DI makes code testable by allowing dependencies to be mocked.

### Without DI (Hard to Test)

```csharp
// Bad: Tight coupling
public class OrderService
{
    private readonly PaymentService _paymentService = new PaymentService();
    
    public void PlaceOrder(Order order)
    {
        _paymentService.Process(order.Payment);
        // Can't mock PaymentService for testing
    }
}
```

### With DI (Easy to Test)

```csharp
// Good: Loose coupling
public class OrderService
{
    private readonly IPaymentService _paymentService;
    
    public OrderService(IPaymentService paymentService)
    {
        _paymentService = paymentService;
    }
    
    public void PlaceOrder(Order order)
    {
        _paymentService.Process(order.Payment);
    }
}

// Unit test
[Test]
public void PlaceOrder_ShouldProcessPayment()
{
    // Arrange
    var mockPaymentService = new Mock<IPaymentService>();
    var orderService = new OrderService(mockPaymentService.Object);
    var order = new Order { /* ... */ };
    
    // Act
    orderService.PlaceOrder(order);
    
    // Assert
    mockPaymentService.Verify(x => x.Process(order.Payment), Times.Once);
}
```

### DI Container Setup (ASP.NET Core)

```csharp
public void ConfigureServices(IServiceCollection services)
{
    // Register dependencies
    services.AddScoped<IOrderService, OrderService>();
    services.AddScoped<IPaymentService, PaymentService>();
    services.AddScoped<IOrderRepository, OrderRepository>();
    services.AddSingleton<ILogger, Logger>();
}
```

---

## 10. Importance of LLD

### Without Good LLD:
- Code duplication across modules
- Hard to test
- Bugs multiply quickly
- Slow development velocity
- High maintenance costs
- Difficult to scale teams
- Technical debt accumulates

### With Good LLD:
- Clean, maintainable code
- Easy to test and debug
- Faster feature delivery
- Code reusability
- Better team collaboration
- Reduced technical debt
- Scalable architecture
- Professional code quality

---

## 11. Real-World Interview Questions

### Google Questions

**Q: How would you design a parking lot system?**
- Classes: ParkingLot, Vehicle, ParkingSpot, PaymentProcessor
- Patterns: Strategy (for pricing), Factory (for vehicle types)
- Focus on: SOLID principles, extensibility

**Q: Design a library management system.**
- Classes: Library, Book, Member, Borrowing Transaction
- Patterns: Repository (for data access), Observer (for notifications)
- Focus on: Class relationships, state management

### Microsoft Questions

**Q: Implement a rate limiter.**
- Data structures: Dictionary for tracking, Queue for sliding window
- Patterns: Singleton (for limiter instance), Strategy (for different algorithms)
- Focus on: Thread safety, performance

**Q: Design a notification system.**
- Classes: NotificationService, INotificationChannel, User, Message
- Patterns: Factory (for channels), Template Method
- Focus on: Extensibility, loose coupling

### Amazon Questions

**Q: Design an e-commerce checkout system.**
- Classes: Cart, Order, Payment, Inventory
- Patterns: Strategy (payment), Chain of Responsibility (validation)
- Focus on: Error handling, transaction management

**Q: Implement a cache with LRU eviction.**
- Data structures: Dictionary + LinkedList
- Focus on: Time complexity O(1) for all operations
- Thread safety considerations

### Meta/Netflix Questions

**Q: Design a recommendation engine component.**
- Classes: RecommendationService, UserProfile, ContentCatalog
- Patterns: Strategy (for algorithms), Repository
- Focus on: Performance, scalability

**Q: Implement a content delivery pipeline.**
- Classes: ContentProcessor, ITranscoder, IStorage, IDistributor
- Patterns: Pipeline, Chain of Responsibility
- Focus on: Async operations, error handling

---

## 12. LLD Checklist & Best Practices

### Before You Start Coding

- [ ] Clarify requirements and constraints
- [ ] Identify core entities and their relationships
- [ ] Define interfaces for abstraction
- [ ] Choose appropriate design patterns
- [ ] Consider error handling strategy
- [ ] Think about testability

### During Design

- [ ] Follow SOLID principles
- [ ] Prefer composition over inheritance
- [ ] Use interfaces for flexibility
- [ ] Choose right data structures for performance
- [ ] Plan for extensibility
- [ ] Document assumptions

### Code Quality Checks

- [ ] Each class has single responsibility
- [ ] Dependencies are injected, not created
- [ ] Methods are small and focused
- [ ] Code is testable
- [ ] Error handling is comprehensive
- [ ] Performance is considered

### Interview Tips

**Do:**
- Start with simple design, then evolve
- Draw class diagrams
- Explain your thought process
- Discuss trade-offs
- Ask clarifying questions
- Mention time/space complexity

**Don't:**
- Jump to code without design
- Over-engineer simple problems
- Ignore edge cases
- Forget about testing
- Skip error handling
- Make assumptions without asking

---

## Summary

**Low-Level Design is about turning architectural ideas into clean, maintainable code.**

**Key Pillars:**
1. **SOLID Principles** - Foundation of good design
2. **Design Patterns** - Proven solutions to common problems
3. **Interfaces & Abstractions** - Enable flexibility and testing
4. **Data Structures** - Impact performance directly
5. **Error Handling** - Make code production-ready
6. **Dependency Injection** - Enable loose coupling and testability

**Remember:** Good LLD demonstrates your ability to write professional, scalable code that other engineers can understand, maintain, and extend. This is what top companies look for in senior engineers.

---
