# Inheritance in C# 

## 1ï¸âƒ£ WHAT is Inheritance?

### ðŸ§’ Simple Definition (Beginner-Friendly)
Inheritance means **a child class automatically gets the data and behavior of a parent class**, and can add or change some of it.

> **Dog ISâ€‘A Animal**  
> **SavingsAccount ISâ€‘A Account**

---

### ðŸŒ Realâ€‘World Analogies

| Real World | Software |
|----------|---------|
| Parent â†’ Child | Base class â†’ Derived class |
| Employee â†’ Manager | Employee â†’ Manager |
| Bank Account â†’ Savings Account | Account â†’ SavingsAccount |

ðŸ‘‰ The child **inherits** common properties and behavior.

---

### â“ What Problem Does Inheritance Solve?

Without inheritance:
- Duplicate fields
- Duplicate logic
- Harder maintenance

Inheritance allows:
- Shared behavior in one place
- Specialized behavior in children

---

### âš™ï¸ Technical Definition (OOP + CLR)

Inheritance is an **ISâ€‘A relationship** where:
- A **derived type extends a base type**
- CLR creates **one object** that contains:
  - Base fields
  - Derived fields

```csharp
class Animal { }
class Dog : Animal { }
```

A `Dog` object **contains an Animal inside it**.

---

### ðŸ§© Inheritance vs Composition (Preview)

- Inheritance â†’ **ISâ€‘A**
- Composition â†’ **HASâ€‘A**

```csharp
class Car : Engine   // âŒ wrong (Car is not an Engine)
class Car { Engine engine; } // âœ… correct
```

---

## 2ï¸âƒ£ WHY Inheritance?

### ðŸš« Problems Without Inheritance

```csharp
class Dog {
    public void Eat() { }
}

class Cat {
    public void Eat() { }
}
```

âŒ Duplication  
âŒ No polymorphism  
âŒ Changes must be repeated

---

### âœ… Benefits

- **Reusability** â€“ shared logic in base class
- **Extensibility** â€“ add behavior in derived class
- **Polymorphism** â€“ base reference â†’ derived object

```csharp
Animal a = new Dog();
```

---

### âš ï¸ When Inheritance Becomes Harmful

- Tight coupling
- Base class changes break children
- Deep hierarchies become rigid

ðŸ“Œ **Interview Insight:**
> Inheritance trades **flexibility** for **reuse**.

---

## 3ï¸âƒ£ Types of Inheritance in C# (MANDATORY)

### 1ï¸âƒ£ Single Inheritance

```csharp
class Animal {
    public void Eat() { }
}

class Dog : Animal {
    public void Bark() { }
}
```

```
Animal
  â–²
 Dog
```

---

### 2ï¸âƒ£ Multilevel Inheritance

```csharp
class Vehicle { }
class Car : Vehicle { }
class ElectricCar : Car { }
```

```
Vehicle
   â–²
  Car
   â–²
ElectricCar
```

---

### 3ï¸âƒ£ Hierarchical Inheritance

```csharp
class Shape { }
class Circle : Shape { }
class Rectangle : Shape { }
```

```
   Shape
   â–²   â–²
Circle Rectangle
```

---

### 4ï¸âƒ£ âŒ Multiple Inheritance (Classes)

```csharp
class A { }
class B { }
class C : A, B // âŒ Not allowed
```

#### âŒ Diamond Problem

```
    A
   â–² â–²
  B   C
   â–²
   D
```

Which `A` should `D` inherit?

---

### âœ… How C# Solves It â€” Interfaces

```csharp
interface IFly { void Fly(); }
interface ISwim { void Swim(); }

class Duck : IFly, ISwim { }
```

---

### 5ï¸âƒ£ Hybrid Inheritance

Class inheritance + multiple interfaces

```csharp
class Animal { }
interface IPet { }

class Dog : Animal, IPet { }
```

---

## 4ï¸âƒ£ HOW Inheritance Works (Code Walkthrough)

### Base Class

```csharp
class Animal
{
    public string Name;

    public virtual void Speak()
    {
        Console.WriteLine("Animal sound");
    }
}
```

### Derived Class

```csharp
class Dog : Animal
{
    public int Age;

    public override void Speak()
    {
        Console.WriteLine("Bark");
    }
}
```

---

### ðŸ§± Constructor Call Order (VERY IMPORTANT)

```csharp
class Animal
{
    public Animal()
    {
        Console.WriteLine("Animal ctor");
    }
}

class Dog : Animal
{
    public Dog()
    {
        Console.WriteLine("Dog ctor");
    }
}
```

```text
Animal ctor
Dog ctor
```

ðŸ“Œ **Base constructor ALWAYS runs first**.

---

## 5ï¸âƒ£ MEMORY VIEW of Inheritance (MANDATORY)

### Code

```csharp
Animal a = new Dog();
```

---

### ðŸ§  Stack vs Heap

```
STACK                         HEAP
-----                         -------------------
a â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  Dog object
                     -------------------
                     | Animal.Name     |
                     | (base field)    |
                     -------------------
                     | Dog.Age         |
                     | (derived field) |
                     -------------------
```

âœ” One object  
âœ” Base + derived fields together  
âœ” Reference stored on stack

---

### ðŸ” Method Call Resolution

```csharp
a.Speak();
```

- Compile-time: method known on `Animal`
- Runtime: CLR checks **actual object type** (`Dog`)
- Calls `Dog.Speak()`

---

## 6ï¸âƒ£ Inheritance at CLR / Runtime Level

### ðŸ§© Object Layout

- Single memory block
- Base fields first
- Derived fields next

---

### ðŸ“‹ Virtual Method Table (vâ€‘table)

- Each type has a vâ€‘table
- Virtual methods point to implementations

```
Animal v-table â†’ Speak â†’ Animal.Speak
Dog v-table    â†’ Speak â†’ Dog.Speak
```

CLR uses objectâ€™s **runtime type** to resolve calls.

---

### â± Compile-Time vs Runtime Binding

| Binding | Happens When | Example |
|------|-------------|--------|
| Compile-time | Non-virtual | static, sealed |
| Runtime | virtual/override | polymorphism |

---

## 7ï¸âƒ£ Inheritance vs Abstraction vs Composition

| Concept | Purpose | Flexibility | Coupling | Example |
|------|--------|------------|---------|--------|
| Inheritance | ISâ€‘A | Low | High | Dog : Animal |
| Abstraction | Contract | Medium | Medium | ILogger |
| Composition | HASâ€‘A | High | Low | Car has Engine |

ðŸ“Œ **Key Truth:**
> Inheritance is NOT abstraction.

---

## 8ï¸âƒ£ Realâ€‘World Case Study (LLD)

### ðŸ§¾ Employee Management System

```csharp
abstract class Employee
{
    public int Id;
    public abstract decimal CalculateSalary();
}

class FullTimeEmployee : Employee
{
    public override decimal CalculateSalary() => 50000;
}

class ContractEmployee : Employee
{
    public override decimal CalculateSalary() => 30000;
}
```

### ðŸ‘ Where It Helps
- Shared identity
- Polymorphic salary calculation

### ðŸ‘Ž Where It Hurts
- Adding bonus rules breaks all subclasses

### âœ… Composition Alternative

```csharp
class Employee
{
    public ISalaryCalculator Calculator;
}
```

---

## âŒ Bad vs âœ… Good Inheritance

### âŒ Bad (Reuseâ€‘Driven)

```csharp
class Logger { void Log() { } }
class FileManager : Logger { } // âŒ FileManager IS NOT Logger
```

### âœ… Good (ISâ€‘A Driven)

```csharp
abstract class Logger { abstract void Log(); }
class FileLogger : Logger { }
```

---

## 9ï¸âƒ£ Interviewâ€‘Ready Section

### ðŸ”‘ Oneâ€‘Liners

- Inheritance models **ISâ€‘A** relationships
- C# does NOT support multiple inheritance of classes
- Polymorphism requires inheritance + virtual methods

---

### â“ Common Questions

**Q: Does C# support multiple inheritance?**  
ðŸ‘‰ No (classes), Yes (interfaces)

**Q: Why is inheritance dangerous?**  
ðŸ‘‰ Tight coupling, fragile base classes

**Q: What happens in memory?**  
ðŸ‘‰ One object with base + derived fields

---

### âš ï¸ Fragile Base Class Problem

- Base class change
- Unexpected derived class break

---

## ðŸ§  FINAL MENTAL MODEL (MANDATORY)

Inheritance means **one object, one memory block, one identity**, where:

- Base class defines **what the object is**
- Derived class defines **what more it can do**
- CLR lays out base + derived fields together
- Virtual calls are resolved using runtime type

> **Inheritance is about ISâ€‘A, not reuse.**  
> It increases coupling and should be used **sparingly and intentionally**.

âœ… Use inheritance when:
- Relationship is truly ISâ€‘A
- Behavior must be polymorphic

âŒ Avoid inheritance when:
- You just want code reuse
- Requirements change frequently

---

ðŸ“Œ **Rule of Thumb:**
> *Prefer composition. Use inheritance only when the model demands it.*

# Constructor Call Order in C# Inheritance (VERY IMPORTANT)

> **Goal:** Understand *exactly* how constructors execute for different object creations by seeing **compiler checks**, **CLR behavior**, and **memory effects**.

---

## Base Classes Used in All Examples

```csharp
class Animal
{
    public Animal()
    {
        Console.WriteLine("Animal ctor");
    }
}

class Dog : Animal
{
    public Dog()
    {
        Console.WriteLine("Dog ctor");
    }
}
```

---

## ðŸ”‘ Golden Rules (Interview-Critical)

1. **Base class constructor always runs first** when creating a derived object
2. **Constructor execution depends on the object being created**, not the reference type
3. **If code does not compile, no constructor is executed**

---

## 1ï¸âƒ£ `Animal a = new Dog();`

### âœ… Compile-time?
âœ” YES â€” valid polymorphism

- Reference type: `Animal`
- Actual object type: `Dog`

---

### ðŸ§  Step-by-Step (CLR View)

1. `new Dog()` is executed
2. CLR allocates **one heap object** large enough for:
   - `Animal` fields
   - `Dog` fields
3. CLR detects inheritance chain: `Animal â†’ Dog`
4. Constructor execution order:
   - `Animal()`
   - `Dog()`
5. Reference is stored in variable `a`

---

### ðŸ–¥ Console Output

```text
Animal ctor
Dog ctor
```

---

### ðŸ§  Memory Visualization

```
STACK                          HEAP
-----                          -----------------------
a â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶             Dog object
                               -----------------------
                               | Animal fields       |
                               | (base part)         |
                               -----------------------
                               | Dog fields          |
                               | (derived part)      |
                               -----------------------
```

âœ” One object
âœ” Base constructed first
âœ” Derived constructed second

---

## 2ï¸âƒ£ `Animal b = new Animal();`

### âœ… Compile-time?
âœ” YES

---

### ðŸ§  Step-by-Step (CLR View)

1. `new Animal()` is executed
2. CLR allocates memory only for `Animal`
3. `Animal()` constructor runs
4. Reference is stored in variable `b`

---

### ðŸ–¥ Console Output

```text
Animal ctor
```

---

### ðŸ§  Memory Visualization

```
STACK                          HEAP
-----                          -----------------------
b â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶             Animal object
                               -----------------------
                               | Animal fields       |
                               -----------------------
```

---

## 3ï¸âƒ£ `Dog c = new Animal();`

### âŒ Compile-time?
âŒ NO â€” compilation error

---

### âŒ Why?

- Variable type: `Dog`
- Object type: `Animal`

This breaks the **IS-A rule**:

> âŒ Every Dog is an Animal, but not every Animal is a Dog

---

### ðŸ›‘ Result

```text
Cannot implicitly convert type 'Animal' to 'Dog'
```

ðŸš« Program does not run
ðŸš« No constructors are executed

---

### ðŸ§  Interview One-Liner

> Base reference â†’ Derived object âœ…  
> Derived reference â†’ Base object âŒ

---

## 4ï¸âƒ£ `Dog d = new Dog();`

### âœ… Compile-time?
âœ” YES

---

### ðŸ§  Step-by-Step (CLR View)

1. `new Dog()` is executed
2. CLR allocates memory for:
   - `Animal` part
   - `Dog` part
3. Constructor execution order:
   - `Animal()`
   - `Dog()`
4. Reference stored in variable `d`

---

### ðŸ–¥ Console Output

```text
Animal ctor
Dog ctor
```

---

### ðŸ§  Memory Visualization

```
STACK                          HEAP
-----                          -----------------------
d â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶             Dog object
                               -----------------------
                               | Animal fields       |
                               -----------------------
                               | Dog fields          |
                               -----------------------
```

---

## ðŸ” Final Summary Table

| Code | Compiles? | Constructors Executed |
|-----|----------|-----------------------|
| `Animal a = new Dog();` | âœ… | `Animal â†’ Dog` |
| `Animal b = new Animal();` | âœ… | `Animal` |
| `Dog c = new Animal();` | âŒ | None |
| `Dog d = new Dog();` | âœ… | `Animal â†’ Dog` |

---

## ðŸ§  FINAL MENTAL MODEL (LOCK THIS IN)

- **Constructor execution follows the inheritance chain, not the variable type**
- CLR always builds objects **top-down** (base â†’ derived)
- If code fails at compile time, **no runtime behavior exists**

> Creating a derived object always means:
> **Base constructor first â†’ Derived constructor next â†’ Reference assignment**

ðŸ“Œ **Interview Rule:**
> *Tell me what object is being created, and Iâ€™ll tell you which constructors run.*

