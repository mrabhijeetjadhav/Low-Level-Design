
# High-Level Design (HLD) and Low-Level Design (LLD)  Overview
### Explained Simply + Interview-Ready (Google, Microsoft, Meta, Amazon, Netflix, Atlassian)

---

## Table of Contents

1. [What is Software Design?](#1-what-is-software-design)
2. [What is High-Level Design (HLD)?](#2-what-is-high-level-design-hld)
   - [What HLD Includes](#what-hld-includes)
   - [Example: Netflix-like System (HLD)](#example-netflix-like-system-hld)
   - [Google-Style HLD Questions](#google-style-hld-questions)
   - [Amazon-Style HLD Questions](#amazon-style-hld-questions)
3. [What is Low-Level Design (LLD)?](#3-what-is-low-level-design-lld)
   - [What LLD Includes](#what-lld-includes)
   - [Example: Movie Service (LLD in C#)](#example-movie-service-lld-in-c)
   - [Google-Style LLD Questions](#google-style-lld-questions)
   - [Microsoft-Style LLD Questions](#microsoft-style-lld-questions)
4. [HLD vs LLD](#4-hld-vs-lld)
5. [How HLD and LLD Work Together](#5-how-hld-and-lld-work-together)
6. [Time & Space Complexity](#6-time--space-complexity-top-companies-care)
7. [Real Case Study: Amazon Order Flow](#7-real-case-study-amazon-order-flow)
8. [Final One-Line Summary](#8-final-one-line-summary)
9. [Comprehensive Summary & Quick Reference](#9-comprehensive-summary--quick-reference)
   - [Core Definitions](#core-definitions)
   - [Key Principles to Remember](#key-principles-to-remember)
   - [Interview Strategy](#interview-strategy)
   - [Common Interview Questions by Company](#common-interview-questions-by-company)
   - [Critical Success Factors](#critical-success-factors)
   - [Design Process Flow](#design-process-flow)
   - [Before Your Interview](#before-your-interview)
   - [Final Takeaway](#final-takeaway)

---

## 1. What is Software Design?

Software design means **thinking before coding**.


### Simple analogy:
If you want to build a **treehouse**, you first decide:
- How big it should be
- Where the ladder goes
- How many rooms

You don’t start hammering randomly.

### For engineers:
Design helps us:
- Reduce bugs
- Scale systems
- Make code readable and maintainable

Big companies expect **clear design thinking** before writing code.

During software engineering interviews, especially at product-based companies, design rounds usually focus on two areas: High-Level Design (HLD), which covers system architecture, and Low-Level Design (LLD), which focuses on detailed component implementation.

**High-Level Design (HLD)** focuses on the overall architecture of the system. It defines the major components, their responsibilities, and how they communicate with each other at a system level.

**Low-Level Design (LLD)** focuses on the internal design of those components. It explains how each component is implemented using classes, interfaces, methods, data structures, and design patterns.

In interview terms:

HLD answers: “What are the core components of the system, and how do they interact?”

LLD answers: “How will each component be implemented in code to ensure scalability, maintainability, and performance?”



---



## 2. What is High-Level Design (HLD)?

### Definition:
**HLD describes WHAT the system is made of and HOW major parts communicate.**

High-Level Design (HLD) defines the overall architecture of a system. It describes how the system is structured and how its major building blocks interact with each other.

At this stage, the focus is on what the system consists of, not how individual components are implemented.

HLD answers the key question:
        “How should the system be organized, and how will its major components communicate?”

### Simple analogy:
HLD is like a **city map**:
- Roads
- Buildings
- Connections  
But no details of rooms inside buildings.

---

## What HLD Includes
- System architecture
- Major components or services
Examples: User Service, Payment Service, Notification Service, Product Catalog
- Communication between components
Examples: REST APIs, gRPC, message queues such as Kafka or RabbitMQ
- Technology stack choices
Examples: Programming language (Java, C#), databases (SQL vs NoSQL), caching layers
- Databases
- Caching
- Scalability, reliability, and availability strategies
Examples: load balancers, database replication, auto-scaling, CDNs
- External or third-party integrations
Examples: Stripe for payments, AWS S3 for storage, email or SMS providers

---

## Example: Netflix-like System (HLD)

```
User
  ↓
Frontend (Web / Mobile)
  ↓
API Gateway
  ↓
---------------------------------
| User Service | Movie Service |
| Payment      | Recommendation |
---------------------------------
  ↓
Cache (Redis) + DB (Cassandra) + CDN
```

### HLD Decisions:
- Stateless services
- CDN for video
- Cache for metadata

---

## Google-Style HLD Questions

**Q1: Why do we separate services instead of one big app?**  
→ To scale and deploy independently.
We separate services instead of building one big application to improve scalability, reliability, maintainability, and team ownership.

Key reasons:

- **Independent scalability**
Different parts of the system have different load patterns. By separating services, we can scale only the services that need it (for example, scaling the Search or Payment service without scaling the entire system).

- **Fault isolation**
If one service fails, it does not bring down the entire system. This improves overall system reliability and availability.

- **Faster development and deployment**
Teams can develop, test, and deploy services independently without waiting on or impacting other teams.

- **Better maintainability and cleaner code**
Each service has a single responsibility, which makes the codebase easier to understand, debug, and extend.

- **Technology flexibility**
Different services can use different technologies, databases, or frameworks based on their specific needs.


**Follow-up:**  
What if everything is one service?  
➡ Any small change requires redeploying the entire application, scaling becomes inefficient, failures affect the whole system, and development slows down as teams step on each other’s code.

---

**Q2: Why use cache?**  
→ Reduce DB load and latency.

We use cache to improve performance, scalability, and reliability by storing frequently accessed data closer to the application so it can be retrieved much faster than from a database or external service.

**Key reasons to use cache:**

- Faster response time
Reading from cache (memory) is much faster than querying a database or calling another service, which reduces user-perceived latency.

- Reduced load on databases and services
Cache prevents repeated requests from hitting the database, helping the system handle high traffic efficiently.

- Improved scalability
By offloading frequent reads to cache, the system can serve more users without scaling the database aggressively.

- Better reliability and stability
If a database is slow or temporarily unavailable, cached data can still be served, allowing graceful degradation.

- Cost optimization
Fewer database queries and external calls reduce infrastructure and operational costs.

**Follow-up:**  

What if cache goes down?  
→ Fall back to DB, degrade gracefully. 
➡ The system should fall back to the database. This is called a cache-aside strategy.


What kind of data should be cached?
➡ Frequently read and rarely changing data (e.g., user profiles, product catalog, configuration data).

What should NOT be cached?
➡ Highly dynamic or sensitive data where strong consistency is required (e.g., real-time balances).

How do you keep cache data fresh?
➡  Using TTL (time-to-live), cache invalidation on updates, or write-through/write-behind strategies.

---

## Amazon-Style HLD Questions

**Q: How do you design for scale?**  
→ Horizontal scaling + stateless services.

**Follow-up:**  

What breaks first when traffic spikes?  
→ Database, so add cache, sharding.

---

## 3. What is Low-Level Design (LLD)?

### Definition:
**LLD explains HOW each part of the system is implemented in code.**

Low-Level Design (LLD) focuses on the detailed design of an individual component or module. It converts high-level architectural ideas into concrete, code-level designs that developers can implement directly.

At this stage, we define the internal structure of a service—including its classes, interfaces, data models, design patterns, and the relationships between them.


### Simple analogy:
LLD is designing:
- Room layout
- Electrical wiring
- Furniture placement

---

## What LLD Includes

For a given module, LLD answers questions such as:
- Classes and interfaces : What classes are required, and what is the responsibility of each class?
- Methods : What fields, methods, and behaviors does each class expose?  What are the exact method signatures, including parameters, return types?
- Relationships : How do classes interact with each other (composition, inheritance, associations)?
- Design patterns : Which design patterns are appropriate (e.g., Factory, Singleton, Strategy)?
- Error handling : What are possible exceptions?
- Performance considerations

Interview one-liner (very useful):
LLD defines how a component is implemented in code, ensuring the design is maintainable, extensible, and testable.

---

## Example: Movie Service (LLD in C#)

```csharp
class Movie
{
    public int Id { get; set; }
    public string Title { get; set; }
}

interface IMovieRepository
{
    Movie GetById(int id);
}

class MovieService
{
    private readonly IMovieRepository _repo;

    public MovieService(IMovieRepository repo)
    {
        _repo = repo;
    }

    public Movie GetMovie(int id)
    {
        return _repo.GetById(id);
    }
}
```

---

## Google-Style LLD Questions

**Q: Why use interfaces?**  
→ Loose coupling and testability.
We use interfaces to achieve loose coupling, flexibility, and testability in software design. Interfaces define what a class should do without tying the code to how it is done.

Key reasons to use interfaces:

- **Loose coupling**
Code depends on abstractions, not concrete implementations. This makes it easy to replace or modify implementations without changing the dependent code.

- **Better testability**
Interfaces allow us to mock or stub dependencies during unit testing, enabling isolated and reliable tests.

- **Supports Dependency Inversion (SOLID)**
High-level modules depend on abstractions rather than concrete classes, leading to cleaner and more maintainable designs.

- **Flexibility and extensibility**
New implementations can be added without impacting existing code, following the Open/Closed Principle.

- **Clear contracts**
Interfaces clearly define expected behavior, making the system easier to understand and collaborate on in large teams.

**Follow-up:**  
What if we don’t use interfaces?  
→ The code becomes tightly coupled, harder to test, and difficult to extend or replace implementations.

When should you avoid interfaces? 
➡ When there is only one implementation and no need for abstraction (e.g., simple utility classes).

---

## Microsoft-Style LLD Questions

**Q: How does Dependency Injection help?**  
→ Makes code testable and flexible.

Dependency Injection (DI) helps by removing tight coupling between classes, making code easier to test, maintain, and extend. Instead of a class creating its own dependencies, those dependencies are provided from the outside.

Why Dependency Injection is important:

- **Loose coupling**
Classes depend on abstractions (interfaces), not concrete implementations. This makes the system flexible and easier to change.

- **Improved testability**
Dependencies can be easily mocked or stubbed in unit tests, allowing isolated and reliable testing.

- **Follows SOLID principles**
Especially the Dependency Inversion Principle—high-level modules should not depend on low-level modules, both should depend on abstractions.

- **Easier maintenance and refactoring**
Changes in one implementation do not ripple through the system, reducing the risk of breaking existing code.

- **Better scalability and extensibility**
New implementations can be introduced without modifying existing business logic.

**Follow-up:**  
What happens if dependencies are created inside classes?  
→ Violates SOLID, hard to change. ➡ The class becomes tightly coupled, hard to test, and difficult to change.

Is DI only for frameworks? 
 → No. DI is a design principle; frameworks like ASP.NET Core just make it easier to implement.

How does DI help large teams? 
 → Teams can work independently on implementations as long as they follow the agreed interface.

---

## 4. HLD vs LLD

| Aspect           | High-Level Design (HLD)                             | Low-Level Design (LLD)                    |
| ---------------- | --------------------------------------------------- | ----------------------------------------- |
| Focus            | Overall system architecture                         | Internal design of individual components  |
| Level of Detail  | Broad and conceptual                                | Detailed and implementation-oriented      |
| Primary Question | *What are the components and how do they interact?* | *How is each component built internally?* |
| Scope            | Entire system                                       | Single service or module                  |
| Audience         | Architects, senior engineers                        | Developers                                |
| Output           | Architecture diagrams, data flow                    | Class diagrams, method definitions        |
| Change Frequency | Relatively low                                      | More frequent                             |
| Interview Usage  | System design rounds                                | LLD / coding design rounds                |


---

## 5. How HLD and LLD Work Together

HLD and LLD are not alternatives. They're sequential steps in the design process.

The design flow works as follows:
1. requirements describe what the system must achieve.
2. High-Level Design (HLD) divides the system into major components and defines how they interact.
3. Low-Level Design (LLD) specifies the internal structure and behavior of each component.
4. the system is implemented by writing code that follows the LLD.

```
Requirements
     ↓
High-Level Design
            ↓
    --------------------------------------
     ↓               ↓                   ↓
---------------------------------------------------
| LLD: Service A | LLD: Service B | LLD: Service C |
---------------------------------------------------
      ↓                  ↓                ↓
---------------------------------------------------
|     CODE A     |     CODE B     |    CODE C     |
---------------------------------------------------
```

### Example: Order System

**HLD:**  
Order Service exists.

**LLD:**

```csharp
class OrderService
{
    private readonly IPayment payment;

    public void PlaceOrder(Order order)
    {
        payment.Pay(order.TotalAmount);
    }
}
```

---

## Google Follow-up:
Can good LLD fix bad HLD?  
→ No. Bad architecture limits scalability.

---

## 6. Time & Space Complexity (Top Companies Care)

```csharp
foreach(var x in items)
```
→ O(n)

```csharp
Dictionary lookup
```
→ O(1)

---

### Google Question:
Why prefer HashMap over List?  
→ Faster lookup at scale.

---

## 7. Real Case Study: Amazon Order Flow

### HLD:
- Order
- Payment
- Inventory

### LLD:
- Validate order
- Reserve inventory
- Process payment
- Persist order

### Failure Handling:
- Payment fails → rollback
- Inventory fails → retry

---

## 8. Final One-Line Summary

**HLD decides WHAT to build.  
LLD decides HOW to build it.  
Top companies expect engineers to master both.**

---

## 9. Comprehensive Summary & Quick Reference

### Core Definitions

**Software Design** = Thinking before coding to build scalable, maintainable systems.

**High-Level Design (HLD)**
- **What it is:** System architecture and component interactions
- **Purpose:** Defines major building blocks and how they communicate
- **Analogy:** City map showing roads and buildings
- **Output:** Architecture diagrams, service boundaries, data flow
- **Interview focus:** "How would you architect this system?"

**Low-Level Design (LLD)**
- **What it is:** Internal implementation of components using classes, interfaces, and patterns
- **Purpose:** Converts architecture into code-level design
- **Analogy:** Room layout with electrical wiring and furniture
- **Output:** Class diagrams, method signatures, design patterns
- **Interview focus:** "How would you implement this component?"

---

### Key Principles to Remember

**For HLD:**
1. **Separation of Concerns** → Independent services for scalability and fault isolation
2. **Caching Strategy** → Reduce DB load and improve response time
3. **Horizontal Scaling** → Stateless services that can scale independently
4. **Technology Choices** → Select appropriate databases, message queues, and frameworks
5. **Reliability Patterns** → Load balancers, replication, CDNs

**For LLD:**
1. **SOLID Principles** → Foundation for maintainable code
2. **Interfaces** → Loose coupling and testability
3. **Dependency Injection** → Flexible and testable code
4. **Design Patterns** → Proven solutions (Factory, Strategy, Repository, etc.)
5. **Error Handling** → Graceful degradation and rollback mechanisms

---

### Interview Strategy

**When asked HLD questions:**
- Start with requirements clarification
- Draw high-level architecture diagram
- Identify major components and their responsibilities
- Explain communication patterns (REST, gRPC, queues)
- Discuss scalability, reliability, and data storage
- Address failure scenarios and trade-offs

**When asked LLD questions:**
- Identify core entities and their relationships
- Define interfaces for abstraction
- Use appropriate design patterns
- Show code structure with classes and methods
- Explain time/space complexity
- Demonstrate testability and extensibility

---

### Common Interview Questions by Company

**Google:**
- Why separate services instead of monolith? → Scalability, fault isolation, independent deployment
- Why use cache? → Reduce latency and DB load
- Why use interfaces? → Loose coupling and testability
- Why prefer HashMap over List? → O(1) vs O(n) lookup

**Microsoft:**
- How does Dependency Injection help? → Testability, flexibility, SOLID compliance
- What design patterns would you use? → Based on the problem (Strategy, Factory, etc.)

**Amazon:**
- How do you design for scale? → Horizontal scaling, stateless services, caching
- What breaks first under load? → Usually database; solve with cache and sharding

**Meta/Netflix:**
- How do you handle failures? → Retries, circuit breakers, graceful degradation
- How do you optimize performance? → Caching, CDNs, database indexing

---

### Critical Success Factors

**Time & Space Complexity:**
- Always analyze algorithm efficiency
- O(1) lookups with Dictionary/HashMap
- O(n) iterations with loops
- Optimize for scale in design decisions

**Trade-offs to Discuss:**
- Consistency vs Availability (CAP theorem)
- SQL vs NoSQL databases
- Caching strategies (cache-aside, write-through)
- Synchronous vs Asynchronous communication

**Failure Handling:**
- Payment fails → Rollback transaction
- Service unavailable → Retry with exponential backoff
- Cache miss → Fall back to database
- Network timeout → Circuit breaker pattern

---

### Design Process Flow

```
1. Understand Requirements
         ↓
2. Create HLD (System Architecture)
         ↓
3. Break down into components
         ↓
4. Create LLD for each component
         ↓
5. Implement with code
         ↓
6. Test and iterate
```

---

### Before Your Interview

**Prepare to answer:**
- What is the difference between HLD and LLD?
- When would you use each type of design?
- Can good LLD compensate for bad HLD? (No—architecture limits scalability)
- How do you ensure your design is testable?
- What design patterns do you commonly use and why?

**Remember:**
- Think out loud during design discussions
- Ask clarifying questions about requirements
- Discuss trade-offs explicitly
- Start simple, then add complexity
- Draw diagrams to communicate clearly
- Always consider scalability, reliability, and maintainability

---

### Final Takeaway

Mastering both HLD and LLD is essential for success at top product companies. **HLD establishes the foundation for scalable architecture, while LLD ensures clean, maintainable implementation.** Together, they demonstrate your ability to think systematically from system design to code execution—a critical skill that separates senior engineers from junior developers.



