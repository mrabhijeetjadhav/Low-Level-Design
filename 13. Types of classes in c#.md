# Types of Classes in C# (Deep Dive with Design Guidance)

> **Goal:** Master *what* each class type is, *why* it exists, *how* to use it correctly, **when NOT to use it**, and **how bad vs good design choices affect real products**. This is written with **product-based interviews and LLD discussions** in mind.

---

## 1Ô∏è‚É£ Concrete (Normal) Class

### What
A **concrete class** is a fully implemented class that **can be instantiated directly**.

### Why
- Represents real-world entities
- Encapsulates state + behavior
- Foundation of object-oriented design

### How
```csharp
class User
{
    public string Name { get; set; }

    public void Login()
    {
        Console.WriteLine($"{Name} logged in");
    }
}

var user = new User { Name = "Abhijeet" };
user.Login();
```

### Real Use Cases
- Domain entities (`User`, `Order`, `Invoice`)
- Application services
- Business logic classes

### ‚ùå When NOT to Use
- When behavior must vary across implementations ‚Üí use **interface/abstract class**
- When the class is only a utility holder ‚Üí use **static class**

### ‚ùå Bad Design
```csharp
class PaymentService
{
    public void Pay()
    {
        // hardcoded logic
    }
}
```
‚ùå Cannot extend, mock, or replace behavior

### ‚úÖ Good Design
```csharp
interface IPaymentService
{
    void Pay();
}

class PaymentService : IPaymentService
{
    public void Pay() { }
}
```

---

## 2Ô∏è‚É£ Abstract Class

### What
An **abstract class** cannot be instantiated and may contain **both implemented and abstract members**.

### Why
- Share base logic
- Enforce mandatory behavior
- Reduce duplication

### How
```csharp
abstract class Payment
{
    public abstract void Pay(decimal amount);

    public void Log()
    {
        Console.WriteLine("Payment logged");
    }
}

class CreditCardPayment : Payment
{
    public override void Pay(decimal amount)
    {
        Console.WriteLine($"Paid {amount} via Credit Card");
    }
}
```

### Real Use Cases
- Payment gateways
- Workflow templates
- Base controllers in ASP.NET

### ‚ùå When NOT to Use
- When multiple inheritance is required
- When no shared implementation exists ‚Üí use **interface**

### ‚ùå Bad Design (Over-Abstraction)
```csharp
abstract class Vehicle
{
    public abstract void OpenSunroof();
}
```
‚ùå Not all vehicles have sunroofs

### ‚úÖ Good Design
```csharp
abstract class Vehicle
{
    public abstract void Drive();
}
```

---

## 3Ô∏è‚É£ Sealed Class

### What
A **sealed class** cannot be inherited.

### Why
- Prevent behavioral changes
- Ensure security
- Enable CLR optimizations

### How
```csharp
sealed class Configuration
{
    public string GetValue(string key) => "value";
}
```

### Real Use Cases
- `System.String`
- Security-sensitive classes
- Value objects

### ‚ùå When NOT to Use
- When extensibility is required
- In framework or library APIs meant for reuse

### ‚ùå Bad Design
```csharp
sealed class BusinessRule { }
```
‚ùå Prevents customization

### ‚úÖ Good Design
```csharp
sealed class JwtToken { }
```

---

## 4Ô∏è‚É£ Static Class

### What
A class that contains **only static members** and cannot be instantiated.

### Why
- Stateless utility behavior
- Performance

### How
```csharp
static class MathUtils
{
    public static int Add(int a, int b) => a + b;
}
```

### Real Use Cases
- Logging helpers
- Math / string utilities

### ‚ùå When NOT to Use
- When dependency injection or mocking is required
- When state is involved

### ‚ùå Bad Design
```csharp
static class OrderService
{
    public static void PlaceOrder() { }
}
```

### ‚úÖ Good Design
```csharp
class OrderService
{
    public void PlaceOrder() { }
}
```

---

## 5Ô∏è‚É£ Partial Class

### What
A class split across **multiple files** using `partial`.

### Why
- Code generation
- Separation of concerns

### How
```csharp
partial class Employee
{
    public int Id { get; set; }
}

partial class Employee
{
    public string Name { get; set; }
}
```

### Real Use Cases
- Entity Framework models
- Designer-generated code

### ‚ùå When NOT to Use
- To artificially split business logic

### ‚ùå Bad Design
Splitting logic across many files ‚Üí hard to debug

---

## 6Ô∏è‚É£ Generic Class

### What
A class that operates on **type parameters**.

### Why
- Type safety
- Reusability
- Performance

### How
```csharp
class Cache<T>
{
    public T Value { get; set; }
}
```

### Real Use Cases
- Repositories
- Caching
- Collections

### ‚ùå When NOT to Use
- When behavior is type-specific

### ‚ùå Bad Design
```csharp
class Processor<T> { }
```
‚ùå No meaningful abstraction

---

## 7Ô∏è‚É£ Nested Class

### What
A class defined inside another class.

### Why
- Strong logical coupling
- Encapsulation

### How
```csharp
class Order
{
    public class OrderItem { }
}
```

### Real Use Cases
- Builder pattern
- Helper types

### ‚ùå When NOT to Use
- When class is reusable independently

---

## 8Ô∏è‚É£ Record Class

### What
A reference type with **value-based equality**.

### Why
- Immutability
- Clean DTOs

### How
```csharp
record Person(string Name, int Age);
```

### Real Use Cases
- API request/response models
- Events

### ‚ùå When NOT to Use
- For entities with identity and lifecycle

### ‚ùå Bad Design
Using records for mutable domain entities

---

## 9Ô∏è‚É£ Singleton Class

### What
Ensures a single instance.

### Why
- Shared resources

### How
```csharp
class Logger
{
    private static readonly Logger _instance = new();
    private Logger() { }
    public static Logger Instance => _instance;
}
```

### ‚ùå When NOT to Use
- Business services
- When testability matters

### ‚ùå Bad Design
Singleton as global state

---

## üîü Base / Derived Classes (Inheritance)

### What
One class inherits another.

### Why
- Polymorphism
- Reuse

### How
```csharp
class Animal
{
    public virtual void Speak() { }
}

class Dog : Animal
{
    public override void Speak() { }
}
```

### ‚ùå When NOT to Use
- Just for code reuse
- When composition fits better

### ‚ùå Bad Design
Deep inheritance hierarchies

---

# ‚ö° Product-Based Interview Questions

### Q1: Why is overusing inheritance bad?
**Answer:** It tightly couples classes and breaks flexibility. Composition is often safer.

### Q2: Why static classes hurt testability?
**Answer:** They cannot be mocked or injected.

### Q3: Why records are not entities?
**Answer:** Entities have identity; records compare by value.

### Q4: When does sealed improve performance?
**Answer:** JIT can devirtualize calls.

---

## ‚úÖ Interview Golden Rule
> **Choosing th