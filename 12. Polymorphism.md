# Polymorphism in C# â€” Runtime, Memory & CLR Visualization

## 1ï¸âƒ£ WHAT is Polymorphism?

### âœ… Simple Definition (Beginner-Friendly)

**Polymorphism means:**
> *The same method call behaves differently depending on the actual object.*

ğŸ‘‰ **Same call, different behavior**

```csharp
animal.Speak(); // Dog speaks differently than Cat
```

---

### ğŸ§  Plain English Explanation

You press **one button**, but **different things happen** based on what is connected.

---

### ğŸŒ Realâ€‘World Analogies

#### ğŸ® Remote Control
| Button | Device | Behavior |
|------|------|--------|
| Power | TV | Turns TV ON |
| Power | AC | Turns AC ON |

#### ğŸ’³ Payment System
```csharp
payment.Pay(); // Card / UPI / NetBanking
```

#### ğŸ¶ Animal
```csharp
animal.Speak(); // Dog barks, Cat meows
```

---

### ğŸ§© Technical Definition (OOP + CLR)

**Polymorphism is the ability of the CLR to invoke the correct method implementation at runtime based on the objectâ€™s actual type, not the reference type.**

- Requires **inheritance or interface**
- Requires **runtime type information (RTTI)**
- Implemented using **dynamic dispatch** (vâ€‘tables / interface maps)

---

### ğŸ•’ Compileâ€‘Time vs Runtime Polymorphism

| Type | Binding | Example |
|---|---|---|
| Compileâ€‘Time | Early | Method Overloading |
| Runtime | Late | Method Overriding / Interface |

---

## 2ï¸âƒ£ WHY Polymorphism?

### âŒ Problems Without Polymorphism

```csharp
if(type == "Dog") Bark();
else if(type == "Cat") Meow();
```

âŒ Problems:
- Rigid code
- Violates **Openâ€“Closed Principle**
- Difficult to extend
- Tight coupling

---

### âœ… Benefits

- âœ” Openâ€“Closed Principle (Open for extension, closed for modification)
- âœ” Clean LLD designs
- âœ” Extensible systems
- âœ” Decoupling

---

### ğŸ¯ Interview Insight

> **Inheritance without polymorphism is useless**

Because:
- Inheritance gives *structure*
- Polymorphism gives *behavior substitution*

---

## 3ï¸âƒ£ TYPES of Polymorphism in C#

---

### ğŸ”¹ 1. Compileâ€‘Time Polymorphism (Static Binding)

### a) Method Overloading

```csharp
class Calculator
{
    int Add(int a, int b) => a + b;
    int Add(int a, int b, int c) => a + b + c;
}
```

#### ğŸ” How Compiler Resolves

- Compiler looks at:
  - Method name
  - Parameter count
  - Parameter types
- Chooses method **at compile time**

âŒ No runtime dispatch
âŒ No vâ€‘table

ğŸ“Œ **This is NOT true runtime polymorphism**

---

### ğŸ”¹ 2. Runtime Polymorphism (Dynamic Binding)

### a) Method Overriding (Inheritance)

```csharp
class Animal
{
    public virtual void Speak()
    {
        Console.WriteLine("Animal speaks");
    }
}

class Dog : Animal
{
    public override void Speak()
    {
        Console.WriteLine("Dog barks");
    }
}
```

#### ğŸ”‘ Keywords
- `virtual` â†’ allows override
- `override` â†’ replaces base behavior
- `base.Speak()` â†’ call parent implementation

---

### ğŸ”¹ 3. Polymorphism via Interfaces

```csharp
interface IPayment
{
    void Pay();
}

class CardPayment : IPayment
{
    public void Pay() => Console.WriteLine("Card Payment");
}
```

#### ğŸ“Œ Why Interfaces?
- Enable **multiple polymorphism**
- No inheritance hierarchy limit
- Strong decoupling

---

## 4ï¸âƒ£ HOW Polymorphism Works (Stepâ€‘byâ€‘Step)

```csharp
Animal a = new Dog();
a.Speak();
```

### ğŸ”¹ Compile Time

- Compiler checks:
  - Does `Animal` have `Speak()`? âœ…
- Generates call as **virtual call**

### ğŸ”¹ Runtime (CLR)

- CLR checks **actual object type â†’ Dog**
- Uses **Dogâ€™s vâ€‘table**
- Executes `Dog.Speak()`

---

## 5ï¸âƒ£ MEMORY VIEW (MANDATORY)

### ğŸ§  Stack vs Heap

```
STACK                        HEAP
-----                        -----------------
a â”€â”€â”€â”€â”€â”€â”                â”Œâ”€> Dog Object
        â”‚                â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€> â”‚ vâ€‘table ptr â”‚
                         â”‚   â”‚ fields      â”‚
                         â”‚   â”‚ Speak() â”€â”€â”€â”€â”¼â”€â”€> Dog.Speak()
                         â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ”‘ Key Points
- `a` is a **reference on stack**
- Object lives on **heap**
- Reference type = `Animal`
- Runtime type = `Dog`

ğŸ“Œ **Runtime type controls behavior**

---

## 6ï¸âƒ£ Polymorphism at CLR / Runtime Level

### ğŸ§± Virtual Method Table (vâ€‘table)

```
Animal vâ€‘table          Dog vâ€‘table
----------------        ----------------
Speak â†’ Animal.Speak   Speak â†’ Dog.Speak
```

- Created **per type**
- Derived type **replaces pointers**

### ğŸ”Œ Interface Dispatch

- Uses **interface map** instead of vâ€‘table
- Slightly slower than virtual calls

### âš™ Performance Note
- Virtual calls are slower than direct calls
- Tradeâ€‘off for flexibility

---

## 7ï¸âƒ£ GOOD vs BAD Polymorphism

### âŒ Bad (Antiâ€‘Pattern)

```csharp
if(type == "Dog") Bark();
else if(type == "Cat") Meow();
```

âŒ Violates OCP
âŒ Hard to maintain

---

### âœ… Good (True OOP)

```csharp
List<Animal> animals = new();
foreach(var a in animals)
    a.Speak();
```

âœ” Extensible
âœ” Clean
âœ” No modification needed for new types

---

## 8ï¸âƒ£ REALâ€‘WORLD LLD CASE STUDY â€” Payment System

```csharp
interface IPayment
{
    void Pay();
}

class CardPayment : IPayment { }
class UpiPayment : IPayment { }
class NetBankingPayment : IPayment { }
```

```csharp
class Checkout
{
    public void Process(IPayment payment)
    {
        payment.Pay();
    }
}
```

### ğŸ”‘ Why Polymorphism?
- Add new payment â†’ **NO code change**
- Interface preferred over inheritance

---

## 9ï¸âƒ£ Polymorphism vs Overloading vs Inheritance

| Concept | Purpose | Binding | Example |
|---|---|---|---|
| Overloading | Convenience | Compileâ€‘time | Add(int,int) |
| Inheritance | Structure | N/A | Dog : Animal |
| Polymorphism | Behavior | Runtime | a.Speak() |

ğŸ“Œ **Polymorphism requires dynamic dispatch**

---

## ğŸ”Ÿ INTERVIEWâ€‘READY SECTION

### âœ… Oneâ€‘Liners

- Polymorphism = runtime behavior substitution
- Overloading is compileâ€‘time, overriding is runtime
- Reference type doesnâ€™t decide behavior â€” runtime type does

---

### â“ Common Questions

**Q: Can constructors be polymorphic?** âŒ
- Constructors are not virtual

**Q: Can static methods be overridden?** âŒ
- Static methods use compileâ€‘time binding

**Q: Why virtual calls are slower?**
- Extra indirection via vâ€‘table

---

## ğŸ§  FINAL MENTAL MODEL

Polymorphism is **not about inheritance** â€” it is about **behavior substitution**.

At runtime:
- Stack holds reference
- Heap holds object
- CLR checks objectâ€™s actual type
- vâ€‘table decides which method runs

ğŸ‘‰ **Polymorphism enables systems that grow without breaking.**

Without runtime type information, polymorphism is impossible.



