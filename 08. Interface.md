# Interfaces in C# 

> **Goal:** Understand *interfaces* by **seeing what happens in memory (stack + heap + CLR metadata)** â€” not just syntax.

---

# 1ï¸âƒ£ WHAT is an Interface?

## 1.1 Simple Definition (Beginner-Friendly)

An **interface** is a **contract**.

It says:
> *â€œAny class that implements me MUST provide these methods.â€*

It defines **what** should be done, **not how**.

```csharp
interface IService
{
    void Send();
}
```

No implementation. Only rules.

---

## 1.2 What Problem Does an Interface Solve?

Without interfaces:

```csharp
class OrderProcessor
{
    EmailService email = new EmailService(); // tightly coupled
}
```

Problems:
- Hard to change implementation
- Hard to test
- Violates SOLID principles

Interfaces **decouple** code.

---

## 1.3 Technical Definition (CLR / Runtime View)

From the **.NET CLR perspective**:

- An interface is **metadata only**
- It contains:
  - Method signatures
  - Method slots (no code)
- No instance data
- No fields

At runtime:
- Interfaces **do NOT exist as objects**
- They are used by the CLR to **dispatch calls**

---

## 1.4 What an Interface Really Is in .NET

Inside the assembly (IL + metadata):

```
Interface: IService
-------------------
Method: void Send()
(No fields)
(No method bodies)
```

CLR stores:
- Interface definition in **metadata tables**
- Mapping between interface methods â†’ class implementations

---

## 1.5 V-Table / Interface Dispatch (High Level)

Each **class object** contains:
- Object header
- Method table pointer

Method table contains:
- Virtual methods
- Interface method mappings

```
[Interface Call]
     â†“
[Method Table]
     â†“
[Concrete Method]
```

---

## 1.6 Why Interfaces Donâ€™t Have Fields

Fields require:
- Memory per object

Interfaces:
- Are never instantiated
- Have no object
- Therefore â†’ **no fields allowed**

---

## 1.7 Interface vs Abstract Class (Conceptual)

| Feature | Interface | Abstract Class |
|------|---------|---------------|
| Fields | âŒ No | âœ… Yes |
| Implementation | âŒ (except default methods) | âœ… |
| Multiple inheritance | âœ… | âŒ |
| Object | âŒ | âŒ |

---

# 2ï¸âƒ£ WHY Use Interfaces?

## 2.1 Problem: Tightly Coupled Code

```csharp
class Report
{
    PdfGenerator pdf = new PdfGenerator();
}
```

You cannot:
- Replace PDF
- Mock for testing

---

## 2.2 Why Inheritance Alone Is Not Enough

Inheritance:
- Creates **IS-A** relationship
- Causes deep hierarchies
- Tight coupling

Interfaces:
- Create **CAN-DO** relationship

---

## 2.3 Dependency Inversion Principle (DIP)

> High-level modules should not depend on low-level modules.

They should depend on **abstractions**.

```csharp
class OrderService
{
    IService service;
}
```

---

## 2.4 Testability & Mocking

```csharp
class FakeService : IService
{
    public void Send() { }
}
```

No real dependency needed.

---

## 2.5 Real-World Analogy

**Switch & Appliance**

- Switch = Interface
- Bulb/Fan = Implementations

Switch does not care *what* is connected.

---

## 2.6 Interview-Oriented Reasons

- Loose coupling
- Plug-and-play design
- Multiple inheritance
- Clean architecture

---

# 3ï¸âƒ£ HOW Interfaces Work (Runtime + Memory)

## 3.1 Class Implements Interface

```csharp
class EmailService : IService
{
    public void Send() { }
}
```

CLR does:
- Validates method signatures
- Updates method table
- Adds interface-method mapping

---

## 3.2 Interface Reference

```csharp
IService s = new EmailService();
```

Important:
- `s` is **NOT** an interface object
- It is a **reference** to a class object

---

## 3.3 Method Call Resolution

```csharp
s.Send();
```

Steps:
1. CLR sees interface call
2. Uses interface slot
3. Looks up method table
4. Jumps to EmailService.Send()

---

## 3.4 Why Interface Variables Donâ€™t Store Data

Interface reference stores:
- Object reference only

No fields. No data.

---

# 4ï¸âƒ£ WHERE Interface References Live in Memory

## Case 1: Interface Reference to Class Object

```csharp
IService s = new EmailService();
```

### Memory Diagram

```
STACK                     HEAP
-----                     -----
 s â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  [EmailService Object]
                          | Header |
                          | Fields |
                          | MT Ptr |
```

- `s` â†’ stack
- Object â†’ heap

---

## Case 2: Interface as Method Parameter

```csharp
void Process(IService service)
```

```
STACK
-----
 service â”€â”€â”€â–¶ HEAP OBJECT
```

Reference copied.

---

## Case 3: Interface as Class Field

```csharp
class Controller
{
    IService service;
}
```

```
HEAP
-----
[Controller]
   â””â”€ service â”€â–¶ [Concrete Object]
```

---

## Case 4: Interface in Collections

```csharp
List<IService> list;
```

```
HEAP
[List]
  â”œâ”€ ref â”€â–¶ Obj1
  â”œâ”€ ref â”€â–¶ Obj2
```

Only references stored.

---

# 5ï¸âƒ£ CODE EXAMPLE (LINE BY LINE MEMORY)

```csharp
IService s;              // Line 1
s = new EmailService();  // Line 2
s.Send();                // Line 3
```

### After Line 1

```
STACK
 s = null
```

### After Line 2

```
STACK                     HEAP
 s â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  [EmailService]
```

### After Line 3

```
Interface dispatch â†’ Method table â†’ Send()
```

---

# 6ï¸âƒ£ INTERFACE vs CLASS vs STRUCT (Memory)

| Feature | Interface | Class | Struct |
|------|----------|-------|--------|
| Allocated | âŒ | Heap | Stack/Inline |
| Fields | âŒ | âœ… | âœ… |
| Reference | Yes | Yes | No |
| Polymorphism | Yes | Yes | Limited |

---

# 7ï¸âƒ£ SPECIAL INTERFACE SCENARIOS

## 7.1 Multiple Interfaces

```csharp
class A : I1, I2 { }
```

Single object. Multiple interface maps.

---

## 7.2 Explicit Interface Implementation

```csharp
void IService.Send() { }
```

Only callable via interface reference.

---

## 7.3 Interface Casting

```csharp
IService s = obj as IService;
```

Runtime checks method table.

---

## 7.4 Boxing with Interfaces

```csharp
IComparable c = 5;
```

```
STACK        HEAP
 c â”€â”€â”€â”€â”€â–¶ [Boxed Int32]
```

---

## 7.5 Default Interface Methods (C# 8+)

- Stored in interface metadata
- Called only if class doesnâ€™t override

---

# 8ï¸âƒ£ INTERVIEW-READY EXPLANATIONS

### One-Liners

- Interface = contract
- No object, only reference
- Enables loose coupling

### Common Questions

- Can interface have fields? âŒ
- Can it be instantiated? âŒ
- Stored on heap? âŒ

### Tricky Follow-ups

- Interface vs abstract class â†’ use interface for behavior contracts
- Performance â†’ slight dispatch cost

---

# 9ï¸âƒ£ DESIGN PERSPECTIVE

## Clean Architecture

- Core depends on interfaces
- Infrastructure implements

## Dependency Injection

```csharp
services.AddScoped<IService, EmailService>();
```

## Unit Testing

- Mock interfaces

## Real Example: Payment Gateway

```csharp
IPaymentGateway
```

---

# ğŸ”Ÿ SUMMARY TABLE

| Scenario | Interface Ref Stored | Object Stored | Why |
|-------|---------------------|--------------|-----|
| Local variable | Stack | Heap | Reference type |
| Field | Heap | Heap | Object graph |
| Parameter | Stack | Heap | Reference copied |
| Collection | Heap | Heap | References only |

---

# ğŸ§  FINAL MENTAL MODEL

An **interface is not an object**. It is a **runtime contract stored in metadata**. An interface reference is just a **pointer** that can point to *any object* whose method table satisfies that contract. The actual data always lives inside the **concrete object on the heap**. When you call an interface method, the CLR uses the objectâ€™s method table to resolve the correct implementation. In interviews, say: *â€œInterfaces enable polymorphism by separating reference type from implementation, with dispatch handled at runtime via metadata and method tables.â€*

