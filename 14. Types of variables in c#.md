# Types of Variables in C#

This document explains **different types of variables in C#** using the **What ‚Üí Why ‚Üí How** framework, with clear explanations, runtime intuition, C# examples, and **product‚Äëbased interview questions with answers**.

---

## 1Ô∏è‚É£ What is a Variable?

### Simple Definition
A **variable** is a named storage location in memory that holds a value which can change during program execution.

### Technical Definition (CLR Perspective)
In C#, a variable is a **reference or value slot** created by the CLR (Common Language Runtime) that maps a name to a memory location (stack, heap, or metadata area) depending on its type and scope.

---

## 2Ô∏è‚É£ Why Do We Need Different Types of Variables?

- Different **lifetimes** (temporary vs long‚Äëlived)
- Different **memory locations** (stack vs heap)
- Different **ownership and scope rules**
- Different **threading and performance characteristics**
- Clear **design intent** (state vs configuration vs constants)

---

## 3Ô∏è‚É£ Types of Variables in C# (High‚ÄëLevel)

C# variables are commonly classified based on:

1. **Scope**
2. **Storage / Lifetime**
3. **Behavior (const vs readonly)**

---

# A. Based on Scope

## 1Ô∏è‚É£ Local Variables

### What
Variables declared **inside a method, constructor, or block**.

### Why
- Short‚Äëlived
- Fast access
- Keeps logic isolated

### How
```csharp
void Calculate()
{
    int sum = 10;   // local variable
    Console.WriteLine(sum);
}
```

### Runtime Insight
- Stored on the **stack** (for value types)
- Lifetime = method execution

---

## 2Ô∏è‚É£ Method Parameters

### What
Variables passed **into a method**.

### Why
- Enables data flow
- Improves reusability

### How
```csharp
void Print(int number)
{
    Console.WriteLine(number);
}
```

### Runtime Insight
- Passed by **value** by default
- Stored on the **stack**

---

## 3Ô∏è‚É£ Instance Variables (Fields)

### What
Variables declared **inside a class but outside methods**.

### Why
- Represent object state
- Each object has its own copy

### How
```csharp
class Person
{
    public string Name;   // instance variable
}

Person p1 = new Person();
Person p2 = new Person();
```

### Runtime Insight
- Stored on the **heap** as part of the object
- Lifetime = object lifetime

---

## 4Ô∏è‚É£ Static Variables

### What
Variables shared by **all instances of a class**.

### Why
- Shared configuration
- Caching
- Global counters

### How
```csharp
class Counter
{
    public static int TotalCount;
}

Counter.TotalCount++;
```

### Runtime Insight
- Stored in **high‚Äëfrequency heap / type metadata area**
- Created once per AppDomain

---

# B. Based on Storage & Behavior

## 5Ô∏è‚É£ Constant Variables (`const`)

### What
Compile‚Äëtime constants.

### Why
- Prevent modification
- Improve performance

### How
```csharp
const int MaxLimit = 100;
```

### Runtime Insight
- **No memory allocation** at runtime
- Value is **inlined** at compile time

‚ö†Ô∏è Changing a const requires recompilation of dependent assemblies.

---

## 6Ô∏è‚É£ Readonly Variables (`readonly`)

### What
Variables that can be assigned **only during declaration or constructor**.

### Why
- Runtime constants
- Safer than mutable fields

### How
```csharp
class Config
{
    public readonly int Timeout;

    public Config(int timeout)
    {
        Timeout = timeout;
    }
}
```

### Runtime Insight
- Stored on heap (instance) or metadata (static)
- Value decided at runtime

---

# C. Special Variable Types

## 7Ô∏è‚É£ Reference Variables

### What
Variables that store **addresses of objects**.

### Why
- Enables object‚Äëoriented behavior

### How
```csharp
Person p = new Person();
```

### Runtime Insight
- Reference on **stack**
- Object on **heap**

---

## 8Ô∏è‚É£ Value Type Variables

### What
Variables that store **actual data**.

### Why
- Faster
- No GC overhead

### How
```csharp
int x = 10;
```

### Runtime Insight
- Stored on stack (local)
- Copied by value

---

## 9Ô∏è‚É£ Nullable Variables

### What
Value types that can hold `null`.

### Why
- Represent missing data

### How
```csharp
int? age = null;
```

### Runtime Insight
- Implemented using `Nullable<T>` struct

---

## üîü Implicitly Typed Variables (`var`)

### What
Compiler infers the type.

### Why
- Cleaner code
- Reduces verbosity

### How
```csharp
var name = "Abhijeet";
```

### Runtime Insight
- Type resolved at **compile time**
- No runtime penalty

---

# D. Interview‚ÄëImportant Comparisons

| Feature | const | readonly | static |
|------|------|----------|--------|
| Compile time | ‚úÖ | ‚ùå | ‚ùå |
| Runtime value | ‚ùå | ‚úÖ | ‚úÖ |
| Memory | Inlined | Heap | Metadata |

---

# Product‚ÄëBased Interview Questions (with Answers)

## Q1Ô∏è‚É£ Why should configuration values not always be `const`?

**Answer:**
`const` values are inlined at compile time. If a library changes a `const`, dependent applications must be recompiled. `readonly` avoids this issue and is safer for versioning.

---

## Q2Ô∏è‚É£ When would you use static variables in a real system?

**Answer:**
- Application‚Äëwide counters
- Cache objects
- Feature flags
- Shared configurations

But misuse leads to **threading issues and memory leaks**.

---

## Q3Ô∏è‚É£ What happens in memory when you write `Person p = new Person()`?

**Answer:**
- `p` (reference) stored on **stack**
- `Person` object stored on **heap**
- `p` points to heap address

---

## Q4Ô∏è‚É£ Is `var` dynamic?

**Answer:**
No. `var` is **statically typed**. The type is resolved at compile time.

---

## Q5Ô∏è‚É£ Why are local variables faster than fields?

**Answer:**
- Stored on stack
- No GC tracking
- Faster access

---

## Q6Ô∏è‚É£ Can static variables cause memory leaks?

**Answer:**
Yes. Static variables live for the entire AppDomain lifetime and prevent GC from collecting referenced objects.

---

## Q7Ô∏è‚É£ Why are value types preferred in performance‚Äëcritical code?

**Answer:**
They avoid heap allocation and garbage collection overhead.

---

## Final Takeaways

- Variable type defines **memory, lifetime, and behavior**
- Choose variables intentionally
- Overusing `static` and `const` is dangerous
- Understanding variables = understanding **CLR behavior**

---

üìå *Mastering variables is the foundation of writing high‚Äëperformance, maintainable C# applications.*

